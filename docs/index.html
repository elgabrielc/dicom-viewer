<!--
DICOM Medical Imaging Viewer - Main Application
===============================================

Divergent Health Technologies
https://divergent.health/

This is a single-page application for viewing DICOM medical imaging studies.
Supports CT, MRI, and other modalities.
All DICOM processing happens client-side using the File System Access API.

Features:
  - Drag-and-drop folder loading
  - Multi-study/series organization
  - Slice navigation with scroll/keyboard
  - Support for JPEG Lossless, JPEG 2000, and uncompressed formats
  - Study and series commenting

Browser Requirements:
  - Chrome 86+ or Edge 86+ (for File System Access API)

Dependencies (loaded via CDN):
  - dicom-parser: DICOM file format parsing
  - jpeg-lossless-decoder-js: JPEG Lossless decompression
  - OpenJPEG WASM: JPEG 2000 decompression (loaded from js/)

Copyright (c) 2026 Divergent Health Technologies
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DICOM Medical Imaging Viewer</title>
    <link rel="stylesheet" href="css/style.css">

    <!-- DICOM parsing library -->
    <script src="https://unpkg.com/dicom-parser@1.8.21/dist/dicomParser.min.js"></script>

    <!-- JPEG Lossless decoder for compressed DICOM images -->
    <script src="https://unpkg.com/jpeg-lossless-decoder-js@1.2.11/release/current/lossless.js"></script>

    <!-- JPEG 2000 decoder (OpenJPEG compiled to WebAssembly) -->
    <script src="js/openjpegwasm_decode.js"></script>
</head>
<body>
    <!-- LIBRARY VIEW -->
    <div id="libraryView" class="container">
        <header>
            <h1>DICOM Medical Imaging Viewer</h1>
            <p class="subtitle">Browse and view CT, MRI, and other imaging studies</p>
        </header>

        <section class="upload-section">
            <div class="folder-load-zone" id="folderZone">
                <div class="folder-load-content">
                    <span class="folder-icon">&#128193;</span>
                    <p class="main-text">Drop a DICOM folder here</p>
                </div>
            </div>
            <div class="sample-section">
                <span class="or-divider">or</span>
                <button id="loadSampleBtn" class="sample-btn">Load Sample CT Scan</button>
            </div>
        </section>

        <section class="studies-section">
            <h2>Studies <span id="studyCount" class="count"></span></h2>
            <div id="emptyState" class="empty-state">
                <p>No studies loaded</p>
                <p class="small">Drop a DICOM folder above to get started</p>
            </div>
            <table id="studiesTable" class="studies-table" style="display: none;">
                <thead>
                    <tr>
                        <th style="width: 30px;"></th>
                        <th>Patient Name</th>
                        <th>Study Date</th>
                        <th>Description</th>
                        <th>Modality</th>
                        <th>Series</th>
                        <th>Images</th>
                        <th>Comments</th>
                    </tr>
                </thead>
                <tbody id="studiesBody"></tbody>
            </table>
        </section>
    </div>

    <!-- VIEWER VIEW -->
    <div id="viewerView" class="viewer-container" style="display: none;">
        <header class="viewer-header">
            <a href="#" class="back-btn" id="backBtn">&larr; Back to Library</a>
            <h1 id="studyTitle">Loading...</h1>
        </header>

        <div class="viewer-main">
            <aside class="series-panel">
                <h3>Series</h3>
                <div id="seriesList" class="series-list"></div>
            </aside>

            <main class="image-panel">
                <div class="viewer-toolbar">
                    <button class="tool-btn active" data-tool="wl" data-tooltip="W">W/L</button>
                    <button class="tool-btn" data-tool="pan" data-tooltip="P">Pan</button>
                    <button class="tool-btn" data-tool="zoom" data-tooltip="Z">Zoom</button>
                    <span class="toolbar-separator"></span>
                    <button class="tool-btn" id="resetViewBtn" data-tooltip="R">Reset</button>
                    <span class="wl-display" id="wlDisplay"></span>
                </div>
                <div class="canvas-container">
                    <canvas id="imageCanvas"></canvas>
                    <div id="imageLoading" class="image-loading" style="display: none;">Loading...</div>
                </div>

                <div class="slice-controls">
                    <button id="prevSlice" class="slice-btn">&lt;</button>
                    <input type="range" id="sliceSlider" min="0" max="0" value="0">
                    <button id="nextSlice" class="slice-btn">&gt;</button>
                    <span id="sliceInfo" class="slice-info">- / -</span>
                </div>
            </main>

            <aside class="metadata-panel">
                <h3>Slice Info</h3>
                <div id="metadataContent" class="metadata-content">
                    <p class="empty">Select a series to view</p>
                </div>
            </aside>
        </div>
    </div>

    <!-- PROGRESS OVERLAY -->
    <div id="uploadProgress" class="upload-progress" style="display: none;">
        <div class="progress-content">
            <p id="progressText">Loading...</p>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%; animation: none;"></div>
            </div>
            <p id="progressDetail" class="progress-detail"></p>
        </div>
    </div>

    <script>
        // =====================================================================
        // DICOM MEDICAL IMAGING VIEWER - CLIENT-SIDE APPLICATION
        // =====================================================================
        //
        // This script implements the entire DICOM viewing workflow:
        //   1. Drag-and-drop folder loading via File System Access API
        //   2. DICOM file parsing and organization by study/series
        //   3. Image decoding (uncompressed, JPEG Lossless, JPEG 2000)
        //   4. Slice navigation and display
        //   5. Study/series commenting
        //
        // The code is organized into the following sections:
        //   - Global State
        //   - DOM Element References
        //   - Utility Functions
        //   - DICOM Parsing
        //   - File System Operations
        //   - Study/Series Processing
        //   - Comments System
        //   - Library View (studies table)
        //   - Transfer Syntax Support
        //   - Image Decoding
        //   - Rendering
        //   - Viewer Controls
        //   - Event Handlers
        //
        // =====================================================================

        // =====================================================================
        // GLOBAL STATE
        // =====================================================================

        /**
         * Global application state
         * @property {Object} studies - Map of studyInstanceUid -> study data
         * @property {Object|null} currentStudy - Currently viewed study
         * @property {Object|null} currentSeries - Currently viewed series
         * @property {number} currentSliceIndex - Index of currently displayed slice
         * @property {Map} sliceCache - Cache of parsed DICOM datasets by slice index
         * @property {string} currentTool - Active tool ('wl', 'pan', 'zoom', or null)
         * @property {Object} viewTransform - Pan and zoom state
         * @property {Object} windowLevel - Current W/L override (null = use DICOM values)
         * @property {Object} baseWindowLevel - Original W/L values for reset
         */
        const state = {
            studies: {},
            currentStudy: null,
            currentSeries: null,
            currentSliceIndex: 0,
            sliceCache: new Map(),
            // Viewing tools state
            currentTool: 'wl',
            viewTransform: { panX: 0, panY: 0, zoom: 1 },
            windowLevel: { center: null, width: null },
            baseWindowLevel: { center: null, width: null },
            isDragging: false,
            dragStart: { x: 0, y: 0 }
        };

        // =====================================================================
        // DOM ELEMENT REFERENCES
        // =====================================================================

        /** Shorthand for getElementById */
        const $ = id => document.getElementById(id);
        const libraryView = $('libraryView');
        const viewerView = $('viewerView');
        const folderZone = $('folderZone');
        const studiesTable = $('studiesTable');
        const studiesBody = $('studiesBody');
        const emptyState = $('emptyState');
        const studyCount = $('studyCount');
        const uploadProgress = $('uploadProgress');
        const progressText = $('progressText');
        const progressDetail = $('progressDetail');
        const progressFill = $('progressFill');
        const canvas = $('imageCanvas');
        const ctx = canvas.getContext('2d');
        const slider = $('sliceSlider');
        const sliceInfo = $('sliceInfo');
        const seriesList = $('seriesList');
        const metadataContent = $('metadataContent');
        const studyTitle = $('studyTitle');
        const imageLoading = $('imageLoading');
        const resetViewBtn = $('resetViewBtn');
        const wlDisplay = $('wlDisplay');
        const prevBtn = $('prevSlice');
        const nextBtn = $('nextSlice');
        const backBtn = $('backBtn');
        const loadSampleBtn = $('loadSampleBtn');

        // =====================================================================
        // UTILITY FUNCTIONS
        // =====================================================================

        /**
         * Format DICOM date string (YYYYMMDD) to readable format (YYYY-MM-DD)
         * @param {string} s - DICOM date string
         * @returns {string} Formatted date or '-' if invalid
         */
        const formatDate = s => s?.length === 8 ? `${s.slice(0,4)}-${s.slice(4,6)}-${s.slice(6,8)}` : s || '-';

        /**
         * Safely get string value from DICOM dataset
         * @param {Object} ds - dicomParser dataset
         * @param {string} tag - DICOM tag (e.g., 'x00100010' for PatientName)
         * @returns {string} Tag value or empty string
         */
        const getString = (ds, tag) => { try { return ds.string(tag) || ''; } catch { return ''; }};

        /**
         * Safely get numeric value from DICOM dataset
         * @param {Object} ds - dicomParser dataset
         * @param {string} tag - DICOM tag
         * @param {number} def - Default value if tag not found
         * @returns {number} Tag value or default
         */
        const getNumber = (ds, tag, def = 0) => { try { const v = ds.string(tag); return v ? parseFloat(v) : def; } catch { return def; }};

        // =====================================================================
        // DICOM PARSING
        // =====================================================================

        /**
         * Parse DICOM file metadata without loading pixel data (fast scan)
         * Used during folder import to organize files by study/series.
         *
         * @param {File} file - File object from File System Access API
         * @returns {Promise<Object|null>} Metadata object or null if not valid DICOM
         */
        async function parseDicomMetadata(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const byteArray = new Uint8Array(arrayBuffer);
                const dataSet = dicomParser.parseDicom(byteArray, { untilTag: 'x7fe00010' });
                const transferSyntax = getString(dataSet, 'x00020010');
                return {
                    patientName: getString(dataSet, 'x00100010'),
                    studyDate: getString(dataSet, 'x00080020'),
                    studyDescription: getString(dataSet, 'x00081030'),
                    studyInstanceUid: getString(dataSet, 'x0020000d'),
                    seriesDescription: getString(dataSet, 'x0008103e'),
                    seriesInstanceUid: getString(dataSet, 'x0020000e'),
                    seriesNumber: getString(dataSet, 'x00200011'),
                    modality: getString(dataSet, 'x00080060'),
                    instanceNumber: getNumber(dataSet, 'x00200013', 0),
                    sliceLocation: getNumber(dataSet, 'x00201041', 0),
                    transferSyntax: transferSyntax,
                };
            } catch { return null; }
        }

        // =====================================================================
        // FILE SYSTEM OPERATIONS
        // Uses File System Access API (Chrome/Edge only)
        // =====================================================================

        /**
         * Recursively get all file handles from a directory
         * @param {FileSystemDirectoryHandle} dirHandle - Directory handle from drop event
         * @param {string} path - Current path (for recursion)
         * @returns {Promise<Array>} Array of {handle, name} objects
         */
        async function getAllFileHandles(dirHandle, path = '') {
            const files = [];
            for await (const [name, handle] of dirHandle.entries()) {
                if (handle.kind === 'file') {
                    files.push({ handle, name });
                } else if (handle.kind === 'directory') {
                    files.push(...await getAllFileHandles(handle, path + name + '/'));
                }
            }
            return files;
        }

        /**
         * Process array of file handles into organized study/series structure
         * Parses each DICOM file's metadata and groups by StudyInstanceUID/SeriesInstanceUID
         *
         * @param {Array} fileHandles - Array of {handle, name} objects
         * @returns {Promise<Object>} Map of studyInstanceUid -> study data
         */
        async function processFiles(fileHandles) {
            const studies = {};
            const total = fileHandles.length;
            let processed = 0, valid = 0;

            const batchSize = 100;
            for (let i = 0; i < fileHandles.length; i += batchSize) {
                const batch = fileHandles.slice(i, i + batchSize);
                await Promise.all(batch.map(async ({ handle }) => {
                    const file = await handle.getFile();
                    const meta = await parseDicomMetadata(file);
                    processed++;

                    if (processed % 200 === 0 || processed === total) {
                        const pct = Math.round((processed / total) * 100);
                        progressFill.style.width = pct + '%';
                        progressText.textContent = `Scanning... ${pct}%`;
                        progressDetail.textContent = `${processed}/${total} files (${valid} DICOM)`;
                    }

                    if (!meta?.studyInstanceUid) return;
                    valid++;

                    const studyUid = meta.studyInstanceUid;
                    const seriesUid = meta.seriesInstanceUid || 'default';

                    if (!studies[studyUid]) {
                        studies[studyUid] = {
                            ...meta, series: {}, seriesCount: 0, imageCount: 0
                        };
                    }
                    if (!studies[studyUid].series[seriesUid]) {
                        studies[studyUid].series[seriesUid] = {
                            seriesInstanceUid: seriesUid,
                            seriesDescription: meta.seriesDescription,
                            seriesNumber: meta.seriesNumber,
                            transferSyntax: meta.transferSyntax,
                            slices: []
                        };
                    }
                    studies[studyUid].series[seriesUid].slices.push({
                        fileHandle: handle,
                        instanceNumber: meta.instanceNumber,
                        sliceLocation: meta.sliceLocation
                    });
                }));
            }

            // Sort and count
            for (const study of Object.values(studies)) {
                let count = 0;
                for (const series of Object.values(study.series)) {
                    series.slices.sort((a, b) => a.instanceNumber - b.instanceNumber || a.sliceLocation - b.sliceLocation);
                    count += series.slices.length;
                }
                study.seriesCount = Object.keys(study.series).length;
                study.imageCount = count;
            }
            return studies;
        }

        // =====================================================================
        // COMMENTS SYSTEM
        // Allows users to add notes to studies and series (stored in memory)
        // =====================================================================

        /**
         * Format Unix timestamp to human-readable date/time
         * @param {number} date - Unix timestamp in milliseconds
         * @returns {string} Formatted date string
         */
        function formatTimestamp(date) {
            return new Date(date).toLocaleString('en-US', {
                month: 'short', day: 'numeric', year: 'numeric',
                hour: 'numeric', minute: '2-digit', hour12: true
            });
        }

        // Render comments list HTML
        function renderComments(comments, studyUid, seriesUid = null) {
            if (!comments || comments.length === 0) return '';
            return comments.map((c, idx) => `
                <div class="comment-item" data-idx="${idx}">
                    <div class="comment-header">
                        <span class="comment-time">${formatTimestamp(c.time)}</span>
                        <span class="comment-actions">
                            <button class="comment-btn edit-comment" data-study-uid="${studyUid}" ${seriesUid ? `data-series-uid="${seriesUid}"` : ''} data-idx="${idx}">Edit</button>
                            <button class="comment-btn delete-comment" data-study-uid="${studyUid}" ${seriesUid ? `data-series-uid="${seriesUid}"` : ''} data-idx="${idx}">Delete</button>
                        </span>
                    </div>
                    <div class="comment-text">${c.text.replace(/</g, '&lt;').replace(/>/g, '&gt;')}</div>
                </div>
            `).join('');
        }

        // Track open panels
        const openPanels = {
            studyPanels: new Set(),
            seriesPanels: new Set(),
            seriesDropdowns: new Set()
        };

        // Update just the comment list without re-rendering everything
        function updateCommentListUI(studyUid, seriesUid) {
            const comments = seriesUid
                ? state.studies[studyUid].series[seriesUid].comments
                : state.studies[studyUid].comments;

            // Find the comment list element
            let commentList;
            if (seriesUid) {
                const panel = document.querySelector(`.series-comment-panel[data-study-uid="${studyUid}"][data-series-uid="${seriesUid}"]`);
                commentList = panel?.querySelector('.comment-list');
            } else {
                const panel = document.querySelector(`.comment-panel-row[data-study-uid="${studyUid}"]`);
                commentList = panel?.querySelector('.comment-list');
            }

            if (commentList) {
                commentList.innerHTML = renderComments(comments, studyUid, seriesUid);
                // Re-attach edit/delete handlers
                commentList.querySelectorAll('.edit-comment').forEach(btn => {
                    btn.onclick = (e) => {
                        e.stopPropagation();
                        editComment(btn.dataset.studyUid, btn.dataset.seriesUid || null, parseInt(btn.dataset.idx));
                    };
                });
                commentList.querySelectorAll('.delete-comment').forEach(btn => {
                    btn.onclick = (e) => {
                        e.stopPropagation();
                        deleteComment(btn.dataset.studyUid, btn.dataset.seriesUid || null, parseInt(btn.dataset.idx));
                    };
                });
            }

            // Update the button text
            const count = comments.length;
            let btn;
            if (seriesUid) {
                btn = document.querySelector(`.series-comment-toggle[data-study-uid="${studyUid}"][data-series-uid="${seriesUid}"]`);
            } else {
                btn = document.querySelector(`.comment-toggle[data-study-uid="${studyUid}"]:not(.series-comment-toggle)`);
            }
            // Keep showing "Hide comments" if panel is open
            if (btn && btn.textContent !== 'Hide comments') {
                btn.textContent = count > 0 ? `${count} comment${count > 1 ? 's' : ''}` : 'Add comment';
            }

            // Clear the input
            let input;
            if (seriesUid) {
                input = document.querySelector(`.add-series-comment[data-study-uid="${studyUid}"][data-series-uid="${seriesUid}"]`);
            } else {
                input = document.querySelector(`.add-study-comment[data-study-uid="${studyUid}"]`);
            }
            if (input) input.value = '';
        }

        // Add comment to study or series
        function addComment(studyUid, seriesUid, text) {
            if (!text.trim()) return;
            const comment = { text: text.trim(), time: Date.now() };
            if (seriesUid) {
                if (!state.studies[studyUid].series[seriesUid].comments) {
                    state.studies[studyUid].series[seriesUid].comments = [];
                }
                state.studies[studyUid].series[seriesUid].comments.push(comment);
            } else {
                if (!state.studies[studyUid].comments) {
                    state.studies[studyUid].comments = [];
                }
                state.studies[studyUid].comments.push(comment);
            }
            updateCommentListUI(studyUid, seriesUid);
        }

        // Delete comment
        function deleteComment(studyUid, seriesUid, idx) {
            if (seriesUid) {
                state.studies[studyUid].series[seriesUid].comments.splice(idx, 1);
            } else {
                state.studies[studyUid].comments.splice(idx, 1);
            }
            updateCommentListUI(studyUid, seriesUid);
        }

        // Edit comment
        function editComment(studyUid, seriesUid, idx) {
            const comments = seriesUid
                ? state.studies[studyUid].series[seriesUid].comments
                : state.studies[studyUid].comments;
            const newText = prompt('Edit comment:', comments[idx].text);
            if (newText !== null && newText.trim()) {
                comments[idx].text = newText.trim();
                comments[idx].time = Date.now();
                updateCommentListUI(studyUid, seriesUid);
            }
        }

        // =====================================================================
        // LIBRARY VIEW (STUDIES TABLE)
        // Renders the main studies list with expandable series rows
        // =====================================================================

        /**
         * Render the studies table in the library view
         * Creates expandable rows for each study with nested series items
         */
        function displayStudies() {
            const studies = Object.values(state.studies);
            if (!studies.length) {
                emptyState.style.display = 'block';
                studiesTable.style.display = 'none';
                studyCount.textContent = '';
                return;
            }
            emptyState.style.display = 'none';
            studiesTable.style.display = 'table';
            studyCount.textContent = `(${studies.length})`;

            let html = '';
            for (const s of studies) {
                const seriesArr = Object.values(s.series);
                if (!Array.isArray(s.comments)) s.comments = [];
                const commentCount = s.comments.length;

                html += `
                    <tr class="study-row" data-uid="${s.studyInstanceUid}">
                        <td class="expand-cell"><span class="expand-icon">&#9654;</span></td>
                        <td>${s.patientName || '-'}</td>
                        <td>${formatDate(s.studyDate)}</td>
                        <td>${s.studyDescription || '-'}</td>
                        <td><span class="modality-badge">${s.modality || '-'}</span></td>
                        <td>${s.seriesCount}</td>
                        <td>${s.imageCount}</td>
                        <td class="comment-cell" onclick="event.stopPropagation()">
                            <button class="comment-toggle" data-study-uid="${s.studyInstanceUid}">
                                ${commentCount > 0 ? `${commentCount} comment${commentCount > 1 ? 's' : ''}` : 'Add comment'}
                            </button>
                        </td>
                    </tr>
                    <tr class="comment-panel-row" data-study-uid="${s.studyInstanceUid}" style="display: none;">
                        <td colspan="8">
                            <div class="detail-panel">
                                <div class="description-section">
                                    <h4>Description</h4>
                                    <textarea class="description-input" data-study-uid="${s.studyInstanceUid}" placeholder="Add a more detailed description...">${(s.description || '').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</textarea>
                                </div>
                                <div class="comment-section">
                                    <h4>Comments</h4>
                                    <div class="comment-list">${renderComments(s.comments, s.studyInstanceUid)}</div>
                                    <div class="comment-add">
                                        <input type="text" class="comment-input add-study-comment" data-study-uid="${s.studyInstanceUid}" placeholder="Write a comment...">
                                        <button class="comment-submit" data-study-uid="${s.studyInstanceUid}">Add</button>
                                    </div>
                                </div>
                            </div>
                        </td>
                    </tr>
                    <tr class="series-dropdown-row" data-study-uid="${s.studyInstanceUid}" style="display: none;">
                        <td colspan="8">
                            <div class="series-dropdown">
                                ${seriesArr.map(ser => {
                                    if (!Array.isArray(ser.comments)) ser.comments = [];
                                    const serCommentCount = ser.comments.length;
                                    const tsInfo = getTransferSyntaxInfo(ser.transferSyntax);
                                    const warningIcon = !tsInfo.supported ? `<span class="format-warning" title="${tsInfo.name} - may not display correctly">&#9888;</span>` : '';
                                    return `
                                    <div class="series-dropdown-item" data-study-uid="${s.studyInstanceUid}" data-series-uid="${ser.seriesInstanceUid}">
                                        <div class="series-main-row">
                                            <span class="series-icon">&#128196;</span>
                                            ${warningIcon}
                                            <span class="series-name">${ser.seriesDescription || 'Series ' + (ser.seriesNumber || '?')}</span>
                                            <span class="series-count">${ser.slices.length} slices</span>
                                            <button class="comment-toggle series-comment-toggle" data-study-uid="${s.studyInstanceUid}" data-series-uid="${ser.seriesInstanceUid}" onclick="event.stopPropagation()">
                                                ${serCommentCount > 0 ? `${serCommentCount} comment${serCommentCount > 1 ? 's' : ''}` : 'Add comment'}
                                            </button>
                                        </div>
                                        <div class="series-comment-panel" data-study-uid="${s.studyInstanceUid}" data-series-uid="${ser.seriesInstanceUid}" style="display: none;" onclick="event.stopPropagation()">
                                            <div class="detail-panel series-detail-panel">
                                                <div class="description-section">
                                                    <h4>Description</h4>
                                                    <textarea class="description-input series-description" data-study-uid="${s.studyInstanceUid}" data-series-uid="${ser.seriesInstanceUid}" placeholder="Add a more detailed description...">${(ser.description || '').replace(/</g, '&lt;').replace(/>/g, '&gt;')}</textarea>
                                                </div>
                                                <div class="comment-section">
                                                    <h4>Comments</h4>
                                                    <div class="comment-list">${renderComments(ser.comments, s.studyInstanceUid, ser.seriesInstanceUid)}</div>
                                                    <div class="comment-add">
                                                        <input type="text" class="comment-input add-series-comment" data-study-uid="${s.studyInstanceUid}" data-series-uid="${ser.seriesInstanceUid}" placeholder="Write a comment...">
                                                        <button class="comment-submit" data-study-uid="${s.studyInstanceUid}" data-series-uid="${ser.seriesInstanceUid}">Add</button>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                `}).join('')}
                            </div>
                        </td>
                    </tr>
                `;
            }
            studiesBody.innerHTML = html;

            // Toggle expand/collapse for series
            studiesBody.querySelectorAll('.study-row').forEach(row => {
                row.onclick = (e) => {
                    if (e.target.closest('.comment-cell')) return;
                    const uid = row.dataset.uid;
                    const dropdownRow = studiesBody.querySelector(`.series-dropdown-row[data-study-uid="${uid}"]`);
                    const icon = row.querySelector('.expand-icon');
                    const isExpanded = dropdownRow.style.display !== 'none';

                    // Close all series dropdowns and track state
                    studiesBody.querySelectorAll('.series-dropdown-row').forEach(r => r.style.display = 'none');
                    studiesBody.querySelectorAll('.expand-icon').forEach(i => { i.textContent = '\u25B6'; i.classList.remove('expanded'); });
                    openPanels.seriesDropdowns.clear();

                    if (!isExpanded) {
                        dropdownRow.style.display = 'table-row';
                        icon.textContent = '\u25BC';
                        icon.classList.add('expanded');
                        openPanels.seriesDropdowns.add(uid);
                    }
                };
            });

            // Toggle study comment panel
            studiesBody.querySelectorAll('.comment-toggle:not(.series-comment-toggle)').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    const studyUid = btn.dataset.studyUid;
                    const panel = studiesBody.querySelector(`.comment-panel-row[data-study-uid="${studyUid}"]`);
                    const isOpen = panel.style.display !== 'none';
                    panel.style.display = isOpen ? 'none' : 'table-row';
                    if (isOpen) {
                        openPanels.studyPanels.delete(studyUid);
                        const count = state.studies[studyUid]?.comments?.length || 0;
                        btn.textContent = count > 0 ? `${count} comment${count > 1 ? 's' : ''}` : 'Add comment';
                    } else {
                        openPanels.studyPanels.add(studyUid);
                        btn.textContent = 'Hide comments';
                    }
                };
            });

            // Toggle series comment panel
            studiesBody.querySelectorAll('.series-comment-toggle').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    const studyUid = btn.dataset.studyUid;
                    const seriesUid = btn.dataset.seriesUid;
                    const key = `${studyUid}:${seriesUid}`;
                    const panel = studiesBody.querySelector(`.series-comment-panel[data-study-uid="${studyUid}"][data-series-uid="${seriesUid}"]`);
                    const isOpen = panel.style.display !== 'none';
                    panel.style.display = isOpen ? 'none' : 'block';
                    if (isOpen) {
                        openPanels.seriesPanels.delete(key);
                        const count = state.studies[studyUid]?.series[seriesUid]?.comments?.length || 0;
                        btn.textContent = count > 0 ? `${count} comment${count > 1 ? 's' : ''}` : 'Add comment';
                    } else {
                        openPanels.seriesPanels.add(key);
                        btn.textContent = 'Hide comments';
                    }
                };
            });

            // Click on series to open viewer
            studiesBody.querySelectorAll('.series-main-row').forEach(row => {
                row.onclick = (e) => {
                    if (e.target.closest('.comment-toggle')) return;
                    const item = row.closest('.series-dropdown-item');
                    const studyUid = item.dataset.studyUid;
                    const seriesUid = item.dataset.seriesUid;
                    openViewerWithSeries(studyUid, seriesUid);
                };
            });

            // Add study comment
            studiesBody.querySelectorAll('.comment-submit:not([data-series-uid])').forEach(btn => {
                btn.onclick = () => {
                    const studyUid = btn.dataset.studyUid;
                    const input = studiesBody.querySelector(`.add-study-comment[data-study-uid="${studyUid}"]`);
                    addComment(studyUid, null, input.value);
                };
            });

            // Add series comment
            studiesBody.querySelectorAll('.comment-submit[data-series-uid]').forEach(btn => {
                btn.onclick = () => {
                    const studyUid = btn.dataset.studyUid;
                    const seriesUid = btn.dataset.seriesUid;
                    const input = studiesBody.querySelector(`.add-series-comment[data-study-uid="${studyUid}"][data-series-uid="${seriesUid}"]`);
                    addComment(studyUid, seriesUid, input.value);
                };
            });

            // Enter key to submit
            studiesBody.querySelectorAll('.comment-input').forEach(input => {
                input.onkeydown = (e) => {
                    if (e.key === 'Enter') {
                        const studyUid = input.dataset.studyUid;
                        const seriesUid = input.dataset.seriesUid || null;
                        addComment(studyUid, seriesUid, input.value);
                    }
                };
            });

            // Edit/Delete buttons
            studiesBody.querySelectorAll('.edit-comment').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    editComment(btn.dataset.studyUid, btn.dataset.seriesUid || null, parseInt(btn.dataset.idx));
                };
            });
            studiesBody.querySelectorAll('.delete-comment').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    deleteComment(btn.dataset.studyUid, btn.dataset.seriesUid || null, parseInt(btn.dataset.idx));
                };
            });

            // Save study description on input
            studiesBody.querySelectorAll('.description-input:not(.series-description)').forEach(textarea => {
                textarea.oninput = () => {
                    const studyUid = textarea.dataset.studyUid;
                    if (state.studies[studyUid]) {
                        state.studies[studyUid].description = textarea.value;
                    }
                };
            });

            // Save series description on input
            studiesBody.querySelectorAll('.series-description').forEach(textarea => {
                textarea.oninput = () => {
                    const studyUid = textarea.dataset.studyUid;
                    const seriesUid = textarea.dataset.seriesUid;
                    if (state.studies[studyUid]?.series[seriesUid]) {
                        state.studies[studyUid].series[seriesUid].description = textarea.value;
                    }
                };
            });

            // Restore open panels
            openPanels.studyPanels.forEach(studyUid => {
                const panel = studiesBody.querySelector(`.comment-panel-row[data-study-uid="${studyUid}"]`);
                if (panel) panel.style.display = 'table-row';
                const btn = studiesBody.querySelector(`.comment-toggle[data-study-uid="${studyUid}"]:not(.series-comment-toggle)`);
                if (btn) btn.textContent = 'Hide comments';
            });
            openPanels.seriesPanels.forEach(key => {
                const [studyUid, seriesUid] = key.split(':');
                const panel = studiesBody.querySelector(`.series-comment-panel[data-study-uid="${studyUid}"][data-series-uid="${seriesUid}"]`);
                if (panel) panel.style.display = 'block';
                const btn = studiesBody.querySelector(`.series-comment-toggle[data-study-uid="${studyUid}"][data-series-uid="${seriesUid}"]`);
                if (btn) btn.textContent = 'Hide comments';
                // Also need to open the series dropdown
                const dropdown = studiesBody.querySelector(`.series-dropdown-row[data-study-uid="${studyUid}"]`);
                if (dropdown) dropdown.style.display = 'table-row';
                const icon = studiesBody.querySelector(`.study-row[data-uid="${studyUid}"] .expand-icon`);
                if (icon) { icon.textContent = '\u25BC'; icon.classList.add('expanded'); }
            });
            openPanels.seriesDropdowns.forEach(studyUid => {
                const dropdown = studiesBody.querySelector(`.series-dropdown-row[data-study-uid="${studyUid}"]`);
                if (dropdown) dropdown.style.display = 'table-row';
                const icon = studiesBody.querySelector(`.study-row[data-uid="${studyUid}"] .expand-icon`);
                if (icon) { icon.textContent = '\u25BC'; icon.classList.add('expanded'); }
            });
        }

        // =====================================================================
        // TRANSFER SYNTAX SUPPORT
        // DICOM images can be stored in various compression formats.
        // The Transfer Syntax UID (0002,0010) identifies the format.
        // =====================================================================

        /**
         * Check if a transfer syntax indicates compressed pixel data
         * @param {string} transferSyntax - Transfer Syntax UID
         * @returns {boolean} True if compressed
         */
        function isCompressed(transferSyntax) {
            if (!transferSyntax) return false;
            // JPEG Lossless, JPEG 2000, JPEG Baseline, RLE, etc.
            return transferSyntax.startsWith('1.2.840.10008.1.2.4') ||
                   transferSyntax === '1.2.840.10008.1.2.5'; // RLE
        }

        function isJpegLossless(transferSyntax) {
            // JPEG Lossless transfer syntaxes
            return transferSyntax === '1.2.840.10008.1.2.4.57' || // JPEG Lossless
                   transferSyntax === '1.2.840.10008.1.2.4.70';   // JPEG Lossless First-Order
        }

        function isJpegBaseline(transferSyntax) {
            return transferSyntax === '1.2.840.10008.1.2.4.50' || // JPEG Baseline
                   transferSyntax === '1.2.840.10008.1.2.4.51';   // JPEG Extended
        }

        function isJpeg2000(transferSyntax) {
            return transferSyntax === '1.2.840.10008.1.2.4.90' || // JPEG 2000 Lossless
                   transferSyntax === '1.2.840.10008.1.2.4.91';   // JPEG 2000 Lossy
        }

        // Transfer syntax names and support status
        const TRANSFER_SYNTAX_INFO = {
            // Uncompressed - Supported
            '1.2.840.10008.1.2': { name: 'Implicit VR Little Endian', supported: true },
            '1.2.840.10008.1.2.1': { name: 'Explicit VR Little Endian', supported: true },
            '1.2.840.10008.1.2.2': { name: 'Explicit VR Big Endian', supported: true },
            // JPEG Lossless - Supported
            '1.2.840.10008.1.2.4.57': { name: 'JPEG Lossless', supported: true },
            '1.2.840.10008.1.2.4.70': { name: 'JPEG Lossless (First-Order Prediction)', supported: true },
            // JPEG Baseline - Supported
            '1.2.840.10008.1.2.4.50': { name: 'JPEG Baseline (8-bit)', supported: true },
            '1.2.840.10008.1.2.4.51': { name: 'JPEG Extended (12-bit)', supported: true },
            // JPEG 2000 - Supported
            '1.2.840.10008.1.2.4.90': { name: 'JPEG 2000 Lossless', supported: true },
            '1.2.840.10008.1.2.4.91': { name: 'JPEG 2000 Lossy', supported: true },
            // RLE - Not supported
            '1.2.840.10008.1.2.5': { name: 'RLE Lossless', supported: false },
            // JPEG-LS - Not supported
            '1.2.840.10008.1.2.4.80': { name: 'JPEG-LS Lossless', supported: false },
            '1.2.840.10008.1.2.4.81': { name: 'JPEG-LS Near-Lossless', supported: false },
            // MPEG - Not supported
            '1.2.840.10008.1.2.4.100': { name: 'MPEG-2', supported: false },
            '1.2.840.10008.1.2.4.101': { name: 'MPEG-2 HD', supported: false },
            '1.2.840.10008.1.2.4.102': { name: 'MPEG-4', supported: false },
            '1.2.840.10008.1.2.4.103': { name: 'MPEG-4 BD', supported: false },
            // Deflated - Not supported
            '1.2.840.10008.1.2.1.99': { name: 'Deflated Explicit VR Little Endian', supported: false },
            // HEVC - Not supported
            '1.2.840.10008.1.2.4.107': { name: 'HEVC/H.265', supported: false },
        };

        function getTransferSyntaxInfo(transferSyntax) {
            if (!transferSyntax) {
                return { name: 'Unknown', supported: false, unknown: true };
            }
            const info = TRANSFER_SYNTAX_INFO[transferSyntax];
            if (info) {
                return { ...info, uid: transferSyntax, unknown: false };
            }
            return { name: `Unknown (${transferSyntax})`, supported: false, unknown: true, uid: transferSyntax };
        }

        // =====================================================================
        // MODALITY-SPECIFIC DEFAULTS
        // Different imaging modalities require different window/level settings
        // =====================================================================

        /**
         * Default window/level values by modality
         * CT uses Hounsfield Units (-1000 air, 0 water, +1000 bone)
         * MR uses arbitrary signal intensity (depends on sequence)
         * Other modalities have their own ranges
         */
        const MODALITY_DEFAULTS = {
            'CT': { windowCenter: 40, windowWidth: 400 },      // Soft tissue window
            'MR': { windowCenter: 512, windowWidth: 1024 },    // Mid-range for typical MRI
            'PT': { windowCenter: 256, windowWidth: 512 },     // PET
            'NM': { windowCenter: 256, windowWidth: 512 },     // Nuclear Medicine
            'US': { windowCenter: 128, windowWidth: 256 },     // Ultrasound (8-bit typical)
            'CR': { windowCenter: 2048, windowWidth: 4096 },   // Computed Radiography
            'DX': { windowCenter: 2048, windowWidth: 4096 },   // Digital X-Ray
            'MG': { windowCenter: 2048, windowWidth: 4096 },   // Mammography
            'XA': { windowCenter: 128, windowWidth: 256 },     // X-Ray Angiography
            'RF': { windowCenter: 128, windowWidth: 256 },     // Radiofluoroscopy
        };

        /**
         * Get default window/level for a modality
         * @param {string} modality - DICOM modality code (CT, MR, etc.)
         * @returns {Object} {windowCenter, windowWidth}
         */
        function getModalityDefaults(modality) {
            return MODALITY_DEFAULTS[modality] || { windowCenter: 128, windowWidth: 256 };
        }

        /**
         * Calculate auto window/level from pixel data statistics
         * Useful for MRI and other modalities without standard units
         * @param {TypedArray} pixelData - Raw pixel values
         * @param {number} rescaleSlope - Rescale slope
         * @param {number} rescaleIntercept - Rescale intercept
         * @returns {Object} {windowCenter, windowWidth, isBlank}
         */
        function calculateAutoWindowLevel(pixelData, rescaleSlope = 1, rescaleIntercept = 0) {
            // Sample pixels for speed (every 10th pixel)
            let min = Infinity, max = -Infinity;
            let sum = 0, count = 0;

            for (let i = 0; i < pixelData.length; i += 10) {
                const value = pixelData[i] * rescaleSlope + rescaleIntercept;
                if (value < min) min = value;
                if (value > max) max = value;
                sum += value;
                count++;
            }

            const mean = sum / count;
            const range = max - min;

            // Detect blank/uniform slices (all pixels have same or nearly same value)
            // This commonly occurs in MPR reconstructions as padding slices
            const isBlank = range < 1;

            // Use percentile-based windowing to handle outliers
            // Center at mean, width covers most of the dynamic range
            const windowWidth = Math.max(range * 0.9, 1);  // 90% of range
            const windowCenter = mean;

            return { windowCenter: Math.round(windowCenter), windowWidth: Math.round(windowWidth), isBlank };
        }

        /**
         * Check if pixel data represents a blank/uniform slice
         * @param {TypedArray} pixelData - Raw pixel values
         * @param {number} rescaleSlope - Rescale slope
         * @param {number} rescaleIntercept - Rescale intercept
         * @returns {boolean} True if slice is blank (all pixels same value)
         */
        function isBlankSlice(pixelData, rescaleSlope = 1, rescaleIntercept = 0) {
            // Sample pixels for speed (every 10th pixel)
            let min = Infinity, max = -Infinity;

            for (let i = 0; i < pixelData.length; i += 10) {
                const value = pixelData[i] * rescaleSlope + rescaleIntercept;
                if (value < min) min = value;
                if (value > max) max = value;
                // Early exit if we find variation
                if (max - min >= 1) return false;
            }

            return (max - min) < 1;
        }

        /**
         * Display a blank slice as black (like Horos)
         * @param {number} rows - Image height
         * @param {number} cols - Image width
         */
        function displayBlankSlice(rows, cols) {
            canvas.width = cols;
            canvas.height = rows;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // =====================================================================
        // IMAGE DECODING
        // Different compression formats require different decoders
        // =====================================================================

        /**
         * Decode JPEG Lossless compressed pixel data
         * Uses the jpeg-lossless-decoder-js library
         *
         * @param {Object} dataSet - dicomParser dataset
         * @param {Object} pixelDataElement - Pixel data element (x7fe00010)
         * @param {number} rows - Image height
         * @param {number} cols - Image width
         * @param {number} bitsAllocated - Bits per pixel (8 or 16)
         * @returns {TypedArray|null} Decoded pixel data or null on failure
         */
        function decodeJpegLossless(dataSet, pixelDataElement, rows, cols, bitsAllocated) {
            try {
                let frameData;

                // Try using dicomParser's built-in function first
                if (pixelDataElement.fragments && pixelDataElement.fragments.length > 0) {
                    frameData = dicomParser.readEncapsulatedPixelDataFromFragments(
                        dataSet, pixelDataElement, 0
                    );
                } else {
                    // Manually parse encapsulated pixel data
                    const byteArray = dataSet.byteArray;
                    let offset = pixelDataElement.dataOffset;

                    // Skip the basic offset table item
                    const itemTag1 = byteArray[offset] | (byteArray[offset+1] << 8);
                    const itemTag2 = byteArray[offset+2] | (byteArray[offset+3] << 8);

                    if (itemTag1 === 0xFFFE && itemTag2 === 0xE000) {
                        const botLength = byteArray[offset+4] | (byteArray[offset+5] << 8) |
                                         (byteArray[offset+6] << 16) | (byteArray[offset+7] << 24);
                        offset += 8 + botLength;

                        const fragTag1 = byteArray[offset] | (byteArray[offset+1] << 8);
                        const fragTag2 = byteArray[offset+2] | (byteArray[offset+3] << 8);

                        if (fragTag1 === 0xFFFE && fragTag2 === 0xE000) {
                            const fragLength = byteArray[offset+4] | (byteArray[offset+5] << 8) |
                                              (byteArray[offset+6] << 16) | (byteArray[offset+7] << 24);
                            offset += 8;
                            frameData = new Uint8Array(byteArray.buffer, byteArray.byteOffset + offset, fragLength);
                        }
                    }
                }

                if (!frameData) {
                    console.error('Could not extract frame data');
                    return null;
                }

                const decoder = new jpeg.lossless.Decoder();
                const decodedData = decoder.decode(frameData.buffer, frameData.byteOffset, frameData.length);

                // Handle the decoded output based on bits allocated
                if (bitsAllocated === 16) {
                    return new Int16Array(decodedData.buffer);
                } else {
                    return new Uint8Array(decodedData.buffer);
                }
            } catch (e) {
                console.error('JPEG Lossless decode error:', e);
                return null;
            }
        }

        // ---------------------------------------------------------------------
        // JPEG 2000 Decoding (OpenJPEG WebAssembly)
        // ---------------------------------------------------------------------

        /** Cached OpenJPEG WASM module instance */
        let openjpegModule = null;
        /** Promise for OpenJPEG initialization (prevents multiple init) */
        let openjpegInitPromise = null;

        /**
         * Initialize the OpenJPEG WebAssembly decoder
         * Lazily loaded on first JPEG 2000 image
         * @returns {Promise<Object>} Initialized OpenJPEG module
         */
        async function initOpenJPEG() {
            if (openjpegModule) return openjpegModule;
            if (openjpegInitPromise) return openjpegInitPromise;

            openjpegInitPromise = (async () => {
                try {
                    console.log('Initializing OpenJPEG WASM...');
                    // OpenJPEGWASM is loaded from the script tag
                    if (typeof OpenJPEGWASM === 'function') {
                        openjpegModule = await OpenJPEGWASM({
                            locateFile: (path) => 'js/' + path
                        });
                        console.log('OpenJPEG WASM initialized successfully');
                        return openjpegModule;
                    }
                    throw new Error('OpenJPEGWASM not found');
                } catch (e) {
                    console.error('Failed to initialize OpenJPEG:', e);
                    throw e;
                }
            })();

            return openjpegInitPromise;
        }

        /**
         * Decode JPEG 2000 compressed pixel data using OpenJPEG WASM
         *
         * @param {Object} dataSet - dicomParser dataset
         * @param {Object} pixelDataElement - Pixel data element (unused, uses dataSet.elements)
         * @param {number} rows - Image height
         * @param {number} cols - Image width
         * @param {number} bitsAllocated - Bits per pixel
         * @param {number} pixelRepresentation - 0=unsigned, 1=signed
         * @returns {Promise<TypedArray|null>} Decoded pixel data or null on failure
         */
        async function decodeJpeg2000(dataSet, pixelDataElement, rows, cols, bitsAllocated, pixelRepresentation) {
            try {
                console.log('Attempting JPEG 2000 decode for', rows, 'x', cols, 'image');

                const pixelDataElement = dataSet.elements.x7fe00010;
                if (!pixelDataElement.encapsulatedPixelData) {
                    console.error('Pixel data is not encapsulated');
                    return null;
                }

                const fragments = pixelDataElement.fragments;
                if (!fragments || fragments.length === 0) {
                    console.error('No fragments found for JPEG 2000');
                    return null;
                }

                // Get the first fragment (single frame)
                const fragment = fragments[0];
                const j2kData = new Uint8Array(dataSet.byteArray.buffer, fragment.position, fragment.length);
                console.log('JPEG 2000 data length:', j2kData.length, 'bytes');

                // Initialize and use OpenJPEG decoder
                const oj = await initOpenJPEG();

                // Use the J2KDecoder class from the WASM module
                const decoder = new oj.J2KDecoder();
                const encodedBuffer = decoder.getEncodedBuffer(j2kData.length);
                encodedBuffer.set(j2kData);

                decoder.decode();

                const decoded = decoder.getDecodedBuffer();
                const frameInfo = decoder.getFrameInfo();

                console.log('JPEG 2000 decoded:', frameInfo.width, 'x', frameInfo.height,
                            'components:', frameInfo.componentCount, 'bpp:', frameInfo.bitsPerSample);

                // Copy decoded data to a new array before cleanup
                let pixelData;
                if (frameInfo.bitsPerSample > 8) {
                    if (frameInfo.isSigned) {
                        pixelData = new Int16Array(decoded.length / 2);
                        const view = new DataView(decoded.buffer, decoded.byteOffset, decoded.byteLength);
                        for (let i = 0; i < pixelData.length; i++) {
                            pixelData[i] = view.getInt16(i * 2, true);
                        }
                    } else {
                        pixelData = new Uint16Array(decoded.length / 2);
                        const view = new DataView(decoded.buffer, decoded.byteOffset, decoded.byteLength);
                        for (let i = 0; i < pixelData.length; i++) {
                            pixelData[i] = view.getUint16(i * 2, true);
                        }
                    }
                } else {
                    pixelData = new Uint8Array(decoded);
                }

                decoder.delete();
                return pixelData;

            } catch (e) {
                console.error('JPEG 2000 decode error:', e);
                return null;
            }
        }

        /**
         * Decode JPEG Baseline compressed pixel data using browser's native decoder
         * Creates a Blob from the JPEG data and uses createImageBitmap to decode
         *
         * @param {Object} dataSet - dicomParser dataset
         * @param {Object} pixelDataElement - Pixel data element (unused)
         * @param {number} rows - Image height
         * @param {number} cols - Image width
         * @returns {Promise<Object|null>} {pixels, isRgb} or null on failure
         */
        async function decodeJpegBaseline(dataSet, pixelDataElement, rows, cols) {
            try {
                const frames = dicomParser.readEncapsulatedPixelDataFromFragments(
                    dataSet, dataSet.elements.x7fe00010, 0
                );

                const blob = new Blob([frames], { type: 'image/jpeg' });
                const bitmap = await createImageBitmap(blob);

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = cols;
                tempCanvas.height = rows;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(bitmap, 0, 0);

                const imageData = tempCtx.getImageData(0, 0, cols, rows);
                // Convert RGBA to grayscale values
                const pixels = new Int16Array(rows * cols);
                for (let i = 0; i < pixels.length; i++) {
                    pixels[i] = imageData.data[i * 4]; // Just use red channel
                }
                return { pixels, isRgb: true };
            } catch (e) {
                console.error('JPEG Baseline decode error:', e);
                return null;
            }
        }

        // =====================================================================
        // RENDERING
        // Converts decoded pixel data to visible image on canvas
        // =====================================================================

        /**
         * Display an error message on the canvas when image cannot be decoded
         * @param {string} message - Main error message
         * @param {string} details - Additional details (e.g., format name)
         */
        function displayError(message, details) {
            canvas.width = 512;
            canvas.height = 512;
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#f0ad4e';
            ctx.font = 'bold 18px -apple-system, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(' Unable to Display Image', canvas.width / 2, 200);

            ctx.fillStyle = '#ccc';
            ctx.font = '14px -apple-system, sans-serif';
            ctx.fillText(message, canvas.width / 2, 240);

            if (details) {
                ctx.fillStyle = '#888';
                ctx.font = '12px -apple-system, sans-serif';
                ctx.fillText(details, canvas.width / 2, 270);
            }

            ctx.fillStyle = '#666';
            ctx.font = '12px -apple-system, sans-serif';
            ctx.fillText('This format may require additional decoders', canvas.width / 2, 310);
        }

        /**
         * Render a DICOM dataset to the canvas
         * Handles decompression, window/level adjustment, and display
         *
         * @param {Object} dataSet - Parsed dicomParser dataset with pixel data
         * @param {Object|null} wlOverride - Optional {center, width} to override DICOM values
         * @returns {Promise<Object>} Rendering info {rows, cols, wc, ww, transferSyntax} or {error: true}
         */
        async function renderDicom(dataSet, wlOverride = null) {
            // Extract image dimensions and pixel format from DICOM tags
            const rows = dataSet.uint16('x00280010');              // (0028,0010) Rows
            const cols = dataSet.uint16('x00280011');              // (0028,0011) Columns
            const bitsAllocated = dataSet.uint16('x00280100') || 16;  // (0028,0100) Bits Allocated
            const pixelRepresentation = dataSet.uint16('x00280103') || 0;  // (0028,0103) 0=unsigned, 1=signed

            // Get modality for appropriate defaults
            const modality = getString(dataSet, 'x00080060');  // (0008,0060) Modality

            // Rescale slope/intercept for converting stored values
            // CT: converts to Hounsfield Units; MR: arbitrary signal intensity
            const rescaleSlope = getNumber(dataSet, 'x00281053', 1);     // (0028,1053)
            const rescaleIntercept = getNumber(dataSet, 'x00281052', 0); // (0028,1052)

            // Window/level for display - use modality-appropriate defaults
            const modalityDefaults = getModalityDefaults(modality);
            let windowCenter = getNumber(dataSet, 'x00281050', 0);  // (0028,1050)
            let windowWidth = getNumber(dataSet, 'x00281051', 0);   // (0028,1051)

            // If window/level not in DICOM, use modality defaults
            // (we'll potentially override with auto-calculation for MRI later)
            const hasWindowLevel = windowCenter !== 0 || windowWidth !== 0;
            if (!hasWindowLevel) {
                windowCenter = modalityDefaults.windowCenter;
                windowWidth = modalityDefaults.windowWidth;
            }

            // Extract MRI-specific metadata
            const mrMetadata = {
                repetitionTime: getNumber(dataSet, 'x00180080', 0),     // (0018,0080) TR
                echoTime: getNumber(dataSet, 'x00180081', 0),          // (0018,0081) TE
                flipAngle: getNumber(dataSet, 'x00181314', 0),         // (0018,1314) Flip Angle
                magneticFieldStrength: getNumber(dataSet, 'x00180087', 0), // (0018,0087) Field Strength
                protocolName: getString(dataSet, 'x00181030'),         // (0018,1030) Protocol Name
                sequenceName: getString(dataSet, 'x00180024'),         // (0018,0024) Sequence Name
                scanningSequence: getString(dataSet, 'x00180020'),     // (0018,0020) Scanning Sequence
                mrAcquisitionType: getString(dataSet, 'x00180023'),    // (0018,0023) MR Acquisition Type (2D/3D)
            };

            // Get transfer syntax to determine compression format
            const transferSyntax = getString(dataSet, 'x00020010');  // (0002,0010)
            console.log('Transfer Syntax:', transferSyntax, 'Compressed:', isCompressed(transferSyntax));

            // Get pixel data element
            const pixelDataElement = dataSet.elements.x7fe00010;  // (7FE0,0010) Pixel Data
            const transferSyntaxInfo = getTransferSyntaxInfo(transferSyntax);

            if (!pixelDataElement) {
                console.error('No pixel data element found');
                displayError('No pixel data found', 'The DICOM file may be corrupted or incomplete');
                return { error: true };
            }

            let pixelData;
            let skipWindowLevel = false;

            // Determine if pixel data is compressed based on transfer syntax
            const isCompressedData = isCompressed(transferSyntax);

            if (isCompressedData) {
                // Decode compressed pixel data using appropriate decoder
                if (isJpeg2000(transferSyntax)) {
                    pixelData = await decodeJpeg2000(dataSet, pixelDataElement, rows, cols, bitsAllocated, pixelRepresentation);
                    if (!pixelData) {
                        displayError('JPEG 2000 decode failed', transferSyntaxInfo.name);
                        return { error: true, transferSyntax, tsInfo: transferSyntaxInfo };
                    }
                } else if (isJpegLossless(transferSyntax)) {
                    pixelData = decodeJpegLossless(dataSet, pixelDataElement, rows, cols, bitsAllocated);
                    if (!pixelData) {
                        displayError('JPEG Lossless decode failed', transferSyntaxInfo.name);
                        return { error: true, transferSyntax, tsInfo: transferSyntaxInfo };
                    }
                } else if (isJpegBaseline(transferSyntax)) {
                    const result = await decodeJpegBaseline(dataSet, pixelDataElement, rows, cols);
                    if (!result) {
                        displayError('JPEG decode failed', transferSyntaxInfo.name);
                        return { error: true, transferSyntax, tsInfo: transferSyntaxInfo };
                    }
                    pixelData = result.pixels;
                    skipWindowLevel = result.isRgb; // Already 0-255 from JPEG decode
                } else {
                    // Unsupported compression format
                    displayError('Unsupported compression format', transferSyntaxInfo.name);
                    return { error: true, transferSyntax, tsInfo: transferSyntaxInfo };
                }
            } else {
                // Uncompressed pixel data - create typed array view directly on buffer
                if (bitsAllocated === 16) {
                    pixelData = pixelRepresentation === 1
                        ? new Int16Array(dataSet.byteArray.buffer, pixelDataElement.dataOffset, pixelDataElement.length / 2)
                        : new Uint16Array(dataSet.byteArray.buffer, pixelDataElement.dataOffset, pixelDataElement.length / 2);
                } else {
                    pixelData = new Uint8Array(dataSet.byteArray.buffer, pixelDataElement.dataOffset, pixelDataElement.length);
                }
            }

            // Check for blank/uniform slices (common in MPR reconstructions as padding)
            // This must be done before window/level calculations
            if (isBlankSlice(pixelData, rescaleSlope, rescaleIntercept)) {
                console.log('Detected blank slice (all pixels same value)');
                displayBlankSlice(rows, cols);
                return {
                    rows, cols,
                    wc: windowCenter, ww: windowWidth,
                    transferSyntax, modality,
                    mrMetadata,
                    isBlank: true
                };
            }

            // For MRI without window/level in DICOM, calculate auto window/level
            // based on actual pixel data statistics
            if (!hasWindowLevel && (modality === 'MR' || modality === 'PT' || modality === 'NM')) {
                const autoWL = calculateAutoWindowLevel(pixelData, rescaleSlope, rescaleIntercept);
                windowCenter = autoWL.windowCenter;
                windowWidth = autoWL.windowWidth;
                console.log(`Auto window/level for ${modality}: C=${windowCenter} W=${windowWidth}`);
            }

            // Store base W/L values for reset (only on first render, not re-renders)
            if (state.baseWindowLevel.center === null) {
                state.baseWindowLevel = { center: windowCenter, width: windowWidth };
            }

            // Apply W/L override if provided (from user drag adjustment)
            if (wlOverride && wlOverride.center !== null && wlOverride.width !== null) {
                windowCenter = wlOverride.center;
                windowWidth = wlOverride.width;
            }

            // Set canvas size to match image dimensions
            canvas.width = cols;
            canvas.height = rows;

            // Create image data buffer for canvas
            const imageData = ctx.createImageData(cols, rows);
            const outputPixels = imageData.data;

            // Calculate window/level range (min/max displayable values)
            const windowMin = windowCenter - windowWidth / 2;
            const windowMax = windowCenter + windowWidth / 2;

            // Apply rescale and window/level transform to each pixel
            for (let i = 0; i < pixelData.length; i++) {
                let grayscaleValue;
                if (skipWindowLevel) {
                    // Already 0-255 (e.g., from JPEG baseline decode)
                    grayscaleValue = pixelData[i];
                } else {
                    // Apply rescale slope/intercept
                    // CT: converts to Hounsfield Units; MR: arbitrary signal intensity
                    let pixelValue = pixelData[i] * rescaleSlope + rescaleIntercept;
                    // Clamp to window range and scale to 0-255
                    pixelValue = Math.max(windowMin, Math.min(windowMax, pixelValue));
                    grayscaleValue = Math.round(((pixelValue - windowMin) / (windowMax - windowMin)) * 255);
                }
                // Set RGBA values (grayscale = R=G=B, alpha=255)
                const pixelIndex = i * 4;
                outputPixels[pixelIndex] = grayscaleValue;      // R
                outputPixels[pixelIndex + 1] = grayscaleValue;  // G
                outputPixels[pixelIndex + 2] = grayscaleValue;  // B
                outputPixels[pixelIndex + 3] = 255;             // A (opaque)
            }

            // Draw to canvas
            ctx.putImageData(imageData, 0, 0);

            return {
                rows, cols,
                wc: windowCenter, ww: windowWidth,
                transferSyntax, modality,
                mrMetadata
            };
        }

        // =====================================================================
        // VIEWER CONTROLS
        // Slice navigation and series selection
        // =====================================================================

        /**
         * Load and display a specific slice from the current series
         * Handles caching and preloading of adjacent slices
         *
         * @param {number} index - Zero-based slice index
         */
        async function loadSlice(index) {
            if (!state.currentSeries) return;
            const slices = state.currentSeries.slices;
            if (index < 0 || index >= slices.length) return;

            state.currentSliceIndex = index;
            updateSliceInfo();
            imageLoading.style.display = 'block';

            try {
                const slice = slices[index];
                let dataSet = state.sliceCache.get(index);

                if (!dataSet) {
                    const file = await slice.fileHandle.getFile();
                    const buf = await file.arrayBuffer();
                    dataSet = dicomParser.parseDicom(new Uint8Array(buf));
                    state.sliceCache.set(index, dataSet);
                }

                // Pass W/L override if user has adjusted values
                const wlOverride = (state.windowLevel.center !== null && state.windowLevel.width !== null)
                    ? state.windowLevel : null;
                const info = await renderDicom(dataSet, wlOverride);

                // Update W/L display in toolbar
                updateWLDisplay();

                if (info && !info.error) {
                    // Build base metadata (common to all modalities)
                    let metadataHtml = `
                        <div class="metadata-item"><div class="label">Slice</div><div class="value">${index + 1} / ${slices.length}</div></div>
                        <div class="metadata-item"><div class="label">Modality</div><div class="value">${info.modality || '-'}</div></div>
                        <div class="metadata-item"><div class="label">Size</div><div class="value">${info.cols} x ${info.rows}</div></div>
                        <div class="metadata-item"><div class="label">Location</div><div class="value">${slice.sliceLocation?.toFixed(2) || '-'} mm</div></div>
                        <div class="metadata-item"><div class="label">Window</div><div class="value">C:${info.wc} W:${info.ww}</div></div>
                    `;

                    // Add MRI-specific metadata
                    if (info.modality === 'MR' && info.mrMetadata) {
                        const mr = info.mrMetadata;
                        metadataHtml += `<div class="metadata-divider"></div>`;

                        if (mr.protocolName) {
                            metadataHtml += `<div class="metadata-item"><div class="label">Protocol</div><div class="value">${mr.protocolName}</div></div>`;
                        }
                        if (mr.sequenceName) {
                            metadataHtml += `<div class="metadata-item"><div class="label">Sequence</div><div class="value">${mr.sequenceName}</div></div>`;
                        }
                        if (mr.repetitionTime) {
                            metadataHtml += `<div class="metadata-item"><div class="label">TR</div><div class="value">${mr.repetitionTime.toFixed(1)} ms</div></div>`;
                        }
                        if (mr.echoTime) {
                            metadataHtml += `<div class="metadata-item"><div class="label">TE</div><div class="value">${mr.echoTime.toFixed(1)} ms</div></div>`;
                        }
                        if (mr.flipAngle) {
                            metadataHtml += `<div class="metadata-item"><div class="label">Flip Angle</div><div class="value">${mr.flipAngle}</div></div>`;
                        }
                        if (mr.magneticFieldStrength) {
                            metadataHtml += `<div class="metadata-item"><div class="label">Field</div><div class="value">${mr.magneticFieldStrength}T</div></div>`;
                        }
                    }

                    metadataContent.innerHTML = metadataHtml;
                } else if (info && info.isBlank) {
                    // Blank/padding slice - show basic info
                    metadataContent.innerHTML = `
                        <div class="metadata-item"><div class="label">Slice</div><div class="value">${index + 1} / ${slices.length}</div></div>
                        <div class="metadata-item"><div class="label">Modality</div><div class="value">${info.modality || '-'}</div></div>
                        <div class="metadata-item"><div class="label">Size</div><div class="value">${info.cols} x ${info.rows}</div></div>
                        <div class="metadata-item"><div class="label">Location</div><div class="value">${slice.sliceLocation?.toFixed(2) || '-'} mm</div></div>
                    `;
                } else if (info && info.error) {
                    metadataContent.innerHTML = `
                        <div class="metadata-item"><div class="label">Slice</div><div class="value">${index + 1} / ${slices.length}</div></div>
                        <div class="metadata-item"><div class="label">Status</div><div class="value" style="color: #f0ad4e;">Decode Error</div></div>
                        <div class="metadata-item"><div class="label">Format</div><div class="value">${info.tsInfo?.name || 'Unknown'}</div></div>
                    `;
                }

                // Preload adjacent
                for (let i = index - 3; i <= index + 3; i++) {
                    if (i >= 0 && i < slices.length && !state.sliceCache.has(i)) {
                        const s = slices[i];
                        s.fileHandle.getFile().then(f => f.arrayBuffer()).then(buf => {
                            state.sliceCache.set(i, dicomParser.parseDicom(new Uint8Array(buf)));
                        }).catch(() => {});
                    }
                }
            } catch (e) {
                console.error('Error loading slice:', e);
            }
            imageLoading.style.display = 'none';
        }

        function updateSliceInfo() {
            const total = state.currentSeries?.slices.length || 0;
            sliceInfo.textContent = `${state.currentSliceIndex + 1} / ${total}`;
            slider.value = state.currentSliceIndex;
            prevBtn.disabled = state.currentSliceIndex <= 0;
            nextBtn.disabled = state.currentSliceIndex >= total - 1;
        }

        function selectSeries(seriesUid) {
            state.currentSeries = state.currentStudy.series[seriesUid];
            state.sliceCache.clear();
            state.currentSliceIndex = 0;

            // Reset view transforms and W/L for new series
            resetViewForNewSeries();

            document.querySelectorAll('.series-item').forEach(el => {
                el.classList.toggle('active', el.dataset.uid === seriesUid);
            });

            slider.max = Math.max(0, state.currentSeries.slices.length - 1);
            slider.value = 0;
            loadSlice(0);
        }

        function openViewer(studyUid, initialSeriesUid = null) {
            state.currentStudy = state.studies[studyUid];
            if (!state.currentStudy) return;

            studyTitle.textContent = `${state.currentStudy.patientName || 'Unknown'} - ${state.currentStudy.studyDescription || 'Study'}`;

            const seriesArr = Object.values(state.currentStudy.series);
            seriesList.innerHTML = seriesArr.map(s => `
                <div class="series-item" data-uid="${s.seriesInstanceUid}">
                    <div class="series-name">${s.seriesDescription || 'Series ' + (s.seriesNumber || '?')}</div>
                    <div class="series-info">${s.slices.length} slices</div>
                </div>
            `).join('');

            seriesList.querySelectorAll('.series-item').forEach(el => {
                el.onclick = () => selectSeries(el.dataset.uid);
            });

            libraryView.style.display = 'none';
            viewerView.style.display = 'flex';
            document.body.classList.add('viewer-page');

            // Select specified series or first one
            const seriesUidToSelect = initialSeriesUid && state.currentStudy.series[initialSeriesUid]
                ? initialSeriesUid
                : (seriesArr.length ? seriesArr[0].seriesInstanceUid : null);
            if (seriesUidToSelect) selectSeries(seriesUidToSelect);
        }

        function openViewerWithSeries(studyUid, seriesUid) {
            openViewer(studyUid, seriesUid);
        }

        function closeViewer() {
            viewerView.style.display = 'none';
            libraryView.style.display = 'block';
            document.body.classList.remove('viewer-page');
            state.currentStudy = null;
            state.currentSeries = null;
            state.sliceCache.clear();
        }

        // =====================================================================
        // VIEWING TOOLS
        // Window/Level, Pan, Zoom, Reset
        // =====================================================================

        /**
         * Set the active viewing tool
         * @param {string} tool - Tool name ('wl', 'pan', 'zoom', or null)
         */
        function setTool(tool) {
            state.currentTool = tool;
            // Update toolbar button states
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tool === tool);
            });
            // Update cursor
            canvas.style.cursor = getCursorForTool(tool, false);
        }

        /**
         * Get appropriate cursor for the current tool
         * @param {string} tool - Tool name
         * @param {boolean} dragging - Whether currently dragging
         * @returns {string} CSS cursor value
         */
        function getCursorForTool(tool, dragging) {
            switch (tool) {
                case 'wl': return dragging ? 'ns-resize' : 'crosshair';
                case 'pan': return dragging ? 'grabbing' : 'grab';
                case 'zoom': return dragging ? 'ns-resize' : 'zoom-in';
                default: return 'default';
            }
        }

        /**
         * Apply CSS transform for pan and zoom
         */
        function applyViewTransform() {
            const { panX, panY, zoom } = state.viewTransform;
            canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
            canvas.style.transformOrigin = 'center center';
        }

        /**
         * Update the W/L display in the toolbar
         */
        function updateWLDisplay() {
            const wc = state.windowLevel.center ?? state.baseWindowLevel.center;
            const ww = state.windowLevel.width ?? state.baseWindowLevel.width;
            if (wc !== null && ww !== null) {
                wlDisplay.textContent = `C: ${Math.round(wc)} W: ${Math.round(ww)}`;
            }
        }

        /**
         * Re-render the current slice with current W/L settings
         */
        async function reRenderCurrentSlice() {
            if (!state.currentSeries) return;
            const dataSet = state.sliceCache.get(state.currentSliceIndex);
            if (dataSet) {
                const wlOverride = (state.windowLevel.center !== null && state.windowLevel.width !== null)
                    ? state.windowLevel : null;
                await renderDicom(dataSet, wlOverride);
            }
        }

        /**
         * Handle Window/Level drag
         */
        function handleWLDrag(dx, dy) {
            const sensitivity = 2;
            const currentWidth = state.windowLevel.width ?? state.baseWindowLevel.width;
            const currentCenter = state.windowLevel.center ?? state.baseWindowLevel.center;

            state.windowLevel.width = Math.max(1, currentWidth + dx * sensitivity);
            state.windowLevel.center = currentCenter - dy * sensitivity;

            reRenderCurrentSlice();
            updateWLDisplay();
        }

        /**
         * Handle Pan drag
         */
        function handlePanDrag(dx, dy) {
            state.viewTransform.panX += dx;
            state.viewTransform.panY += dy;
            applyViewTransform();
        }

        /**
         * Handle Zoom drag
         */
        function handleZoomDrag(dx, dy) {
            const sensitivity = 0.005;
            const delta = -dy * sensitivity;
            state.viewTransform.zoom = Math.max(0.1, Math.min(10, state.viewTransform.zoom + delta));
            applyViewTransform();
        }

        /**
         * Reset view to default state
         */
        function resetView() {
            state.viewTransform = { panX: 0, panY: 0, zoom: 1 };
            state.windowLevel = { center: null, width: null };
            applyViewTransform();
            reRenderCurrentSlice();
            updateWLDisplay();
        }

        /**
         * Reset view when switching series
         */
        function resetViewForNewSeries() {
            state.viewTransform = { panX: 0, panY: 0, zoom: 1 };
            state.windowLevel = { center: null, width: null };
            state.baseWindowLevel = { center: null, width: null };
            applyViewTransform();
        }

        // Mouse event handlers for canvas tools
        function onCanvasMouseDown(e) {
            if (!state.currentTool || e.button !== 0) return;
            state.isDragging = true;
            state.dragStart = { x: e.clientX, y: e.clientY };
            canvas.style.cursor = getCursorForTool(state.currentTool, true);
            e.preventDefault();
        }

        function onCanvasMouseMove(e) {
            if (!state.isDragging) return;
            const dx = e.clientX - state.dragStart.x;
            const dy = e.clientY - state.dragStart.y;

            switch (state.currentTool) {
                case 'wl': handleWLDrag(dx, dy); break;
                case 'pan': handlePanDrag(dx, dy); break;
                case 'zoom': handleZoomDrag(dx, dy); break;
            }

            state.dragStart = { x: e.clientX, y: e.clientY };
        }

        function onCanvasMouseUp(e) {
            if (state.isDragging) {
                state.isDragging = false;
                canvas.style.cursor = getCursorForTool(state.currentTool, false);
            }
        }

        // =====================================================================
        // EVENT HANDLERS
        // Drag-and-drop, keyboard navigation, mouse wheel scrolling
        // =====================================================================

        // Drag-and-drop handlers for folder loading
        folderZone.addEventListener('dragover', e => { e.preventDefault(); folderZone.classList.add('dragover'); });
        folderZone.addEventListener('dragleave', e => { e.preventDefault(); folderZone.classList.remove('dragover'); });

        folderZone.addEventListener('drop', async e => {
            e.preventDefault();
            folderZone.classList.remove('dragover');

            uploadProgress.style.display = 'flex';
            progressText.textContent = 'Reading folder...';
            progressDetail.textContent = '';
            progressFill.style.width = '0%';

            try {
                const items = e.dataTransfer.items;
                if (!items?.[0]?.getAsFileSystemHandle) {
                    throw new Error('Please use Chrome or Edge for folder drop support');
                }

                const handle = await items[0].getAsFileSystemHandle();
                if (handle.kind !== 'directory') {
                    throw new Error('Please drop a folder, not a file');
                }

                progressText.textContent = 'Finding files...';
                const fileHandles = await getAllFileHandles(handle);
                progressDetail.textContent = `Found ${fileHandles.length} files`;

                if (!fileHandles.length) throw new Error('No files found');

                state.studies = await processFiles(fileHandles);
                uploadProgress.style.display = 'none';
                displayStudies();

            } catch (err) {
                uploadProgress.style.display = 'none';
                alert('Error: ' + err.message);
            }
        });

        backBtn.onclick = e => { e.preventDefault(); closeViewer(); };
        slider.oninput = () => loadSlice(parseInt(slider.value));
        prevBtn.onclick = () => { if (state.currentSliceIndex > 0) loadSlice(state.currentSliceIndex - 1); };
        nextBtn.onclick = () => {
            if (state.currentSeries && state.currentSliceIndex < state.currentSeries.slices.length - 1)
                loadSlice(state.currentSliceIndex + 1);
        };

        // Load sample CT scan button
        loadSampleBtn.onclick = async () => {
            loadSampleBtn.disabled = true;
            loadSampleBtn.textContent = 'Loading...';
            uploadProgress.style.display = 'flex';
            progressText.textContent = 'Loading sample scan...';
            progressDetail.textContent = '';
            progressFill.style.width = '0%';

            try {
                // Fetch the manifest of sample files
                const manifestRes = await fetch('sample/manifest.json');
                const fileNames = await manifestRes.json();

                progressText.textContent = 'Downloading DICOM files...';
                progressDetail.textContent = `0/${fileNames.length} files`;

                // Fetch all DICOM files
                const filePromises = fileNames.map(async (name, i) => {
                    const res = await fetch(`sample/${name}`);
                    const blob = await res.blob();
                    // Update progress periodically
                    if ((i + 1) % 5 === 0 || i === fileNames.length - 1) {
                        const pct = Math.round(((i + 1) / fileNames.length) * 50);
                        progressFill.style.width = pct + '%';
                        progressDetail.textContent = `${i + 1}/${fileNames.length} files`;
                    }
                    return { name, blob };
                });

                const files = await Promise.all(filePromises);

                progressText.textContent = 'Processing DICOM files...';
                progressFill.style.width = '50%';

                // Process files similar to processFiles but with blobs
                const studies = {};
                let processed = 0;

                for (const { name, blob } of files) {
                    const meta = await parseDicomMetadata(blob);
                    processed++;

                    const pct = 50 + Math.round((processed / files.length) * 50);
                    progressFill.style.width = pct + '%';
                    progressDetail.textContent = `Processing ${processed}/${files.length}`;

                    if (!meta?.studyInstanceUid) continue;

                    const studyUid = meta.studyInstanceUid;
                    const seriesUid = meta.seriesInstanceUid;

                    if (!studies[studyUid]) {
                        studies[studyUid] = {
                            ...meta,
                            series: {},
                            comments: []
                        };
                    }

                    if (!studies[studyUid].series[seriesUid]) {
                        studies[studyUid].series[seriesUid] = {
                            seriesInstanceUid: seriesUid,
                            seriesNumber: meta.seriesNumber,
                            seriesDescription: meta.seriesDescription,
                            modality: meta.modality,
                            slices: [],
                            comments: []
                        };
                    }

                    studies[studyUid].series[seriesUid].slices.push({
                        instanceNumber: meta.instanceNumber,
                        sliceLocation: meta.sliceLocation,
                        blob: blob  // Store blob instead of handle
                    });
                }

                // Sort slices
                for (const study of Object.values(studies)) {
                    for (const series of Object.values(study.series)) {
                        series.slices.sort((a, b) =>
                            (a.sliceLocation ?? a.instanceNumber ?? 0) -
                            (b.sliceLocation ?? b.instanceNumber ?? 0)
                        );
                    }
                }

                state.studies = studies;
                uploadProgress.style.display = 'none';
                displayStudies();
                loadSampleBtn.textContent = 'Load Sample CT Scan';
                loadSampleBtn.disabled = false;

            } catch (err) {
                uploadProgress.style.display = 'none';
                loadSampleBtn.textContent = 'Load Sample CT Scan';
                loadSampleBtn.disabled = false;
                alert('Error loading sample: ' + err.message);
            }
        };

        document.addEventListener('keydown', e => {
            if (viewerView.style.display === 'none') return;

            // Tool shortcuts (only when not typing in an input)
            if (e.target.tagName !== 'INPUT' && e.target.tagName !== 'TEXTAREA') {
                switch (e.key.toLowerCase()) {
                    case 'w': setTool('wl'); return;
                    case 'p': setTool('pan'); return;
                    case 'z': setTool('zoom'); return;
                    case 'r': resetView(); return;
                }
            }

            // Navigation shortcuts
            if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
                e.preventDefault();
                if (state.currentSliceIndex > 0) loadSlice(state.currentSliceIndex - 1);
            } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
                e.preventDefault();
                if (state.currentSeries && state.currentSliceIndex < state.currentSeries.slices.length - 1)
                    loadSlice(state.currentSliceIndex + 1);
            } else if (e.key === 'Escape') {
                closeViewer();
            }
        });

        // Canvas mouse events for tools
        canvas.addEventListener('mousedown', onCanvasMouseDown);
        canvas.addEventListener('mousemove', onCanvasMouseMove);
        canvas.addEventListener('mouseup', onCanvasMouseUp);
        canvas.addEventListener('mouseleave', onCanvasMouseUp);

        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            if (state.currentTool === 'zoom') {
                // Zoom mode: scroll to zoom
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                state.viewTransform.zoom = Math.max(0.1, Math.min(10, state.viewTransform.zoom + delta));
                applyViewTransform();
            } else {
                // Default: scroll to navigate slices
                if (e.deltaY > 0) {
                    if (state.currentSeries && state.currentSliceIndex < state.currentSeries.slices.length - 1)
                        loadSlice(state.currentSliceIndex + 1);
                } else {
                    if (state.currentSliceIndex > 0) loadSlice(state.currentSliceIndex - 1);
                }
            }
        });

        // Toolbar button events
        document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
            btn.addEventListener('click', () => setTool(btn.dataset.tool));
        });
        resetViewBtn.addEventListener('click', resetView);

        // Initialize cursor for default tool
        canvas.style.cursor = getCursorForTool(state.currentTool, false);

        // =====================================================================
        // TEST MODE
        // When ?test is in the URL, load test data from the server API
        // instead of requiring File System Access API folder drop.
        // This enables automated testing with Playwright/Puppeteer.
        // =====================================================================

        /** Test mode flag - set when ?test URL parameter is present */
        const isTestMode = new URLSearchParams(window.location.search).has('test');

        /**
         * Load test data from the server API
         * @returns {Promise<Object>} Studies object matching the normal state.studies format
         */
        async function loadTestData() {
            const response = await fetch('/api/test-data/studies');
            if (!response.ok) throw new Error('Failed to load test data');

            const studiesArray = await response.json();
            const studies = {};

            for (const study of studiesArray) {
                const seriesMap = {};
                for (const series of study.series) {
                    seriesMap[series.seriesInstanceUid] = {
                        seriesInstanceUid: series.seriesInstanceUid,
                        seriesDescription: series.seriesDescription,
                        seriesNumber: series.seriesNumber,
                        modality: series.modality,
                        // Create slice objects that use API URLs instead of fileHandles
                        slices: Array.from({ length: series.sliceCount }, (_, i) => ({
                            instanceNumber: i + 1,
                            sliceLocation: 0,
                            // Store API info for test mode loading
                            testMode: true,
                            studyId: study.studyInstanceUid,
                            seriesId: series.seriesInstanceUid,
                            sliceIndex: i
                        }))
                    };
                }

                studies[study.studyInstanceUid] = {
                    patientName: study.patientName,
                    studyDate: study.studyDate,
                    studyDescription: study.studyDescription,
                    studyInstanceUid: study.studyInstanceUid,
                    modality: study.modality,
                    seriesCount: study.seriesCount,
                    imageCount: study.imageCount,
                    series: seriesMap
                };
            }

            return studies;
        }

        /**
         * Load a slice in test mode (fetches from API instead of fileHandle)
         * This is called from loadSlice when the slice has testMode: true
         */
        async function loadTestSlice(slice) {
            const url = `/api/test-data/dicom/${slice.studyId}/${slice.seriesId}/${slice.sliceIndex}`;
            const response = await fetch(url);
            if (!response.ok) throw new Error(`Failed to load test slice: ${response.status}`);

            const arrayBuffer = await response.arrayBuffer();
            return dicomParser.parseDicom(new Uint8Array(arrayBuffer));
        }

        // Patch loadSlice to handle test mode
        const originalLoadSlice = loadSlice;
        loadSlice = async function(index) {
            if (!state.currentSeries) return;
            const slices = state.currentSeries.slices;
            if (index < 0 || index >= slices.length) return;

            const slice = slices[index];

            // If this is a test mode slice, fetch from API
            if (slice.testMode) {
                state.currentSliceIndex = index;
                updateSliceInfo();
                imageLoading.style.display = 'block';

                try {
                    let dataSet = state.sliceCache.get(index);

                    if (!dataSet) {
                        dataSet = await loadTestSlice(slice);
                        state.sliceCache.set(index, dataSet);
                    }

                    // Pass W/L override if user has adjusted values
                    const wlOverride = (state.windowLevel.center !== null && state.windowLevel.width !== null)
                        ? state.windowLevel : null;
                    const info = await renderDicom(dataSet, wlOverride);

                    // Update W/L display in toolbar
                    updateWLDisplay();

                    if (info && !info.error && !info.isBlank) {
                        let metadataHtml = `
                            <div class="metadata-item"><div class="label">Slice</div><div class="value">${index + 1} / ${slices.length}</div></div>
                            <div class="metadata-item"><div class="label">Modality</div><div class="value">${info.modality || '-'}</div></div>
                            <div class="metadata-item"><div class="label">Size</div><div class="value">${info.cols} x ${info.rows}</div></div>
                            <div class="metadata-item"><div class="label">Window</div><div class="value">C:${info.wc} W:${info.ww}</div></div>
                        `;
                        metadataContent.innerHTML = metadataHtml;
                    }

                    // Preload adjacent slices
                    for (let i = index - 2; i <= index + 2; i++) {
                        if (i >= 0 && i < slices.length && !state.sliceCache.has(i)) {
                            loadTestSlice(slices[i]).then(ds => {
                                state.sliceCache.set(i, ds);
                            }).catch(() => {});
                        }
                    }
                } catch (e) {
                    console.error('Error loading test slice:', e);
                }

                imageLoading.style.display = 'none';
                return;
            }

            // Normal mode - use original function
            return originalLoadSlice.call(this, index);
        };

        // Auto-load test data if in test mode
        if (isTestMode) {
            console.log('Test mode enabled - loading test data from server');
            (async () => {
                try {
                    uploadProgress.style.display = 'flex';
                    progressText.textContent = 'Loading test data...';
                    progressDetail.textContent = '';

                    state.studies = await loadTestData();

                    uploadProgress.style.display = 'none';
                    displayStudies();

                    // Auto-open first study/series if available
                    const studyIds = Object.keys(state.studies);
                    if (studyIds.length > 0) {
                        const firstStudy = state.studies[studyIds[0]];
                        const seriesIds = Object.keys(firstStudy.series);
                        if (seriesIds.length > 0) {
                            console.log('Auto-opening first series for testing');
                            openViewerWithSeries(studyIds[0], seriesIds[0]);
                        }
                    }
                } catch (e) {
                    console.error('Failed to load test data:', e);
                    uploadProgress.style.display = 'none';
                    alert('Failed to load test data: ' + e.message);
                }
            })();
        } else {
            displayStudies();
        }
    </script>
</body>
</html>
