<!--
DICOM Medical Imaging Viewer - Main Application
===============================================

Divergent Health Technologies
https://divergent.health/

This is a single-page application for viewing DICOM medical imaging studies.
Supports CT, MRI, and other modalities.
All DICOM processing happens client-side using the File System Access API.

Features:
  - Drag-and-drop folder loading
  - Multi-study/series organization
  - Slice navigation with scroll/keyboard
  - Support for JPEG Lossless, JPEG 2000, and uncompressed formats
  - Study and series commenting

Browser Requirements:
  - Chrome 86+ or Edge 86+ (for File System Access API)

Dependencies (vendored in js/vendor/):
  - dicom-parser: DICOM file format parsing
  - jpeg-lossless-decoder-js: JPEG Lossless decompression
  - OpenJPEG WASM: JPEG 2000 decompression (loaded from js/)

Copyright (c) 2026 Divergent Health Technologies
-->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>DICOM Medical Imaging Viewer</title>
    <link rel="stylesheet" href="css/style.css">

    <!-- DICOM parsing library -->
    <script src="js/vendor/dicomParser.min.js"></script>

    <!-- JPEG Lossless decoder for compressed DICOM images -->
    <script src="js/vendor/lossless.js"></script>

    <!-- JPEG 2000 decoder (OpenJPEG compiled to WebAssembly) -->
    <script src="js/openjpegwasm_decode.js"></script>

    <!-- Application configuration (deployment mode, feature flags) -->
    <script src="js/config.js"></script>

    <!-- In-app user guide content -->
    <script src="js/help-content.js"></script>

    <!-- Notes API abstraction (server persistence with graceful fallback) -->
    <script src="js/api.js"></script>
</head>
<body>
    <!-- LIBRARY VIEW -->
    <div id="libraryView" class="container">
        <header class="library-header">
            <h1>DICOM Medical Imaging Viewer</h1>
            <p class="subtitle">Browse and view CT, MRI, and other imaging studies</p>
            <button class="help-btn library-help-btn" aria-label="Open user guide" data-tooltip="H">?</button>
        </header>

        <section class="upload-section">
            <div class="folder-load-zone" id="folderZone">
                <div class="folder-load-content">
                    <span class="folder-icon">&#128193;</span>
                    <p class="main-text">Drop a DICOM folder here</p>
                </div>
            </div>
            <div class="sample-section">
                <span class="or-divider">or try a sample</span>
                <button id="loadSampleCtBtn" class="sample-btn">CT Scan</button>
                <button id="loadSampleMriBtn" class="sample-btn">MRI Scan</button>
            </div>
        </section>

        <section class="studies-section">
            <h2>Studies <span id="studyCount" class="count"></span></h2>
            <div id="emptyState" class="empty-state">
                <p>No studies loaded</p>
                <p class="small">Drop a DICOM folder above to get started</p>
            </div>
            <table id="studiesTable" class="studies-table" style="display: none;">
                <thead>
                    <tr>
                        <th style="width: 30px;"></th>
                        <th>Patient Name</th>
                        <th>Study Date</th>
                        <th>Description</th>
                        <th>Modality</th>
                        <th>Series</th>
                        <th>Images</th>
                        <th>Comments</th>
                        <th>Reports</th>
                    </tr>
                </thead>
                <tbody id="studiesBody"></tbody>
            </table>
        </section>
    </div>

    <!-- VIEWER VIEW -->
    <div id="viewerView" class="viewer-container" style="display: none;">
        <header class="viewer-header">
            <a href="#" class="back-btn" id="backBtn">&larr; Back to Library</a>
            <h1 id="studyTitle">Loading...</h1>
            <button class="help-btn viewer-help-btn" aria-label="Open user guide" data-tooltip="H">?</button>
        </header>

        <div class="viewer-main">
            <aside class="series-panel">
                <h3>Series</h3>
                <div id="seriesList" class="series-list"></div>
            </aside>

            <main class="image-panel">
                <div class="viewer-toolbar">
                    <button class="tool-btn active" data-tool="wl" data-tooltip="W">W/L</button>
                    <button class="tool-btn" data-tool="pan" data-tooltip="P">Pan</button>
                    <button class="tool-btn" data-tool="zoom" data-tooltip="Z">Zoom</button>
                    <button class="tool-btn" data-tool="measure" data-tooltip="M">Measure</button>
                    <span class="toolbar-separator"></span>
                    <button class="tool-btn" id="resetViewBtn" data-tooltip="R">Reset</button>
                    <span class="calibration-warning" id="calibrationWarning" style="display: none;">Uncalibrated</span>
                    <span class="wl-display" id="wlDisplay"></span>
                </div>
                <div class="canvas-container">
                    <canvas id="imageCanvas"></canvas>
                    <canvas id="measurementCanvas"></canvas>
                    <div id="imageLoading" class="image-loading" style="display: none;">Loading...</div>
                </div>

                <div class="slice-controls">
                    <button id="prevSlice" class="slice-btn">&lt;</button>
                    <input type="range" id="sliceSlider" min="0" max="0" value="0">
                    <button id="nextSlice" class="slice-btn">&gt;</button>
                    <span id="sliceInfo" class="slice-info">- / -</span>
                </div>
            </main>

            <aside class="metadata-panel">
                <h3>Slice Info</h3>
                <div id="metadataContent" class="metadata-content">
                    <p class="empty">Select a series to view</p>
                </div>
            </aside>
        </div>
    </div>

    <!-- PROGRESS OVERLAY -->
    <div id="uploadProgress" class="upload-progress" style="display: none;">
        <div class="progress-content">
            <p id="progressText">Loading...</p>
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill" style="width: 0%; animation: none;"></div>
            </div>
            <p id="progressDetail" class="progress-detail"></p>
        </div>
    </div>

    <!-- REPORT VIEWER MODAL -->
    <div id="reportViewer" class="report-viewer" style="display: none;">
        <div class="report-viewer-header">
            <span id="reportViewerTitle">Report</span>
            <button id="closeReportViewer" class="report-viewer-close">&times;</button>
        </div>
        <div class="report-viewer-content">
            <iframe id="reportPdfFrame" style="display: none;"></iframe>
            <img id="reportImageView" style="display: none;">
        </div>
    </div>

    <!-- HELP VIEWER MODAL -->
    <div id="helpViewer" class="help-viewer" style="display: none;" role="dialog" aria-modal="true" aria-labelledby="helpViewerTitle">
        <div class="help-viewer-header">
            <span id="helpViewerTitle">User Guide</span>
            <button id="closeHelpViewer" class="help-viewer-close" aria-label="Close help">&times;</button>
        </div>
        <div class="help-viewer-body">
            <nav class="help-viewer-sidebar" id="helpToc"></nav>
            <div class="help-viewer-content" id="helpContent"></div>
        </div>
    </div>

    <script>
        // =====================================================================
        // DICOM MEDICAL IMAGING VIEWER - CLIENT-SIDE APPLICATION
        // =====================================================================
        //
        // This script implements the entire DICOM viewing workflow:
        //   1. Drag-and-drop folder loading via File System Access API
        //   2. DICOM file parsing and organization by study/series
        //   3. Image decoding (uncompressed, JPEG Lossless, JPEG 2000)
        //   4. Slice navigation and display
        //   5. Study/series commenting
        //
        // The code is organized into the following sections:
        //   - Global State
        //   - DOM Element References
        //   - Utility Functions
        //   - DICOM Parsing
        //   - File System Operations
        //   - Study/Series Processing
        //   - Comments System
        //   - Library View (studies table)
        //   - Transfer Syntax Support
        //   - Image Decoding
        //   - Rendering
        //   - Viewer Controls
        //   - Event Handlers
        //
        // =====================================================================

        // =====================================================================
        // LRU CACHE
        // =====================================================================

        /**
         * Least Recently Used cache backed by a Map.
         * JavaScript Maps iterate in insertion order, so deleting and
         * re-inserting a key on access moves it to the end (most recent).
         * Eviction removes from the front (least recent).
         */
        class LRUCache {
            constructor(maxSize) {
                this._maxSize = maxSize;
                this._map = new Map();
            }

            get(key) {
                if (!this._map.has(key)) return undefined;
                // Move to end (most recently used)
                const value = this._map.get(key);
                this._map.delete(key);
                this._map.set(key, value);
                return value;
            }

            set(key, value) {
                // If key already exists, delete first so re-insert moves it to end
                if (this._map.has(key)) {
                    this._map.delete(key);
                }
                this._map.set(key, value);
                // Evict oldest entries if over capacity
                while (this._map.size > this._maxSize) {
                    const oldest = this._map.keys().next().value;
                    this._map.delete(oldest);
                }
            }

            has(key) {
                return this._map.has(key);
            }

            clear() {
                this._map.clear();
            }
        }

        const SLICE_CACHE_MAX_ENTRIES = 100;

        // =====================================================================
        // GLOBAL STATE
        // =====================================================================

        /**
         * Global application state
         * @property {Object} studies - Map of studyInstanceUid -> study data
         * @property {Object|null} currentStudy - Currently viewed study
         * @property {Object|null} currentSeries - Currently viewed series
         * @property {number} currentSliceIndex - Index of currently displayed slice
         * @property {LRUCache} sliceCache - LRU cache of parsed DICOM datasets by slice index
         * @property {string} currentTool - Active tool ('wl', 'pan', 'zoom', or null)
         * @property {Object} viewTransform - Pan and zoom state
         * @property {Object} windowLevel - Current W/L override (null = use DICOM values)
         * @property {Object} baseWindowLevel - Original W/L values for reset
         */
        const state = {
            studies: {},
            currentStudy: null,
            currentSeries: null,
            currentSliceIndex: 0,
            sliceCache: new LRUCache(SLICE_CACHE_MAX_ENTRIES),
            // Viewing tools state
            currentTool: 'wl',
            viewTransform: { panX: 0, panY: 0, zoom: 1 },
            windowLevel: { center: null, width: null },
            baseWindowLevel: { center: null, width: null },
            isDragging: false,
            dragStart: { x: 0, y: 0 },
            // Measurement tool state
            measurements: new Map(),    // Map<sliceKey, Measurement[]> - keyed by study/series/slice
            activeMeasurement: null,    // Measurement being drawn
            pixelSpacing: null          // {row, col} in mm, or null if uncalibrated
        };

        // =====================================================================
        // DOM ELEMENT REFERENCES
        // =====================================================================

        /** Shorthand for getElementById */
        const $ = id => document.getElementById(id);
        const libraryView = $('libraryView');
        const viewerView = $('viewerView');
        const folderZone = $('folderZone');
        const studiesTable = $('studiesTable');
        const studiesBody = $('studiesBody');
        const emptyState = $('emptyState');
        const studyCount = $('studyCount');
        const uploadProgress = $('uploadProgress');
        const progressText = $('progressText');
        const progressDetail = $('progressDetail');
        const progressFill = $('progressFill');
        const canvas = $('imageCanvas');
        const ctx = canvas.getContext('2d');
        const slider = $('sliceSlider');
        const sliceInfo = $('sliceInfo');
        const seriesList = $('seriesList');
        const metadataContent = $('metadataContent');
        const studyTitle = $('studyTitle');
        const imageLoading = $('imageLoading');
        const resetViewBtn = $('resetViewBtn');
        const wlDisplay = $('wlDisplay');
        const measurementCanvas = $('measurementCanvas');
        const measureCtx = measurementCanvas.getContext('2d');
        const calibrationWarning = $('calibrationWarning');
        const canvasContainer = document.querySelector('.canvas-container');
        const prevBtn = $('prevSlice');
        const nextBtn = $('nextSlice');
        const backBtn = $('backBtn');
        const loadSampleCtBtn = $('loadSampleCtBtn');
        const loadSampleMriBtn = $('loadSampleMriBtn');

        // =====================================================================
        // UTILITY FUNCTIONS
        // =====================================================================

        /**
         * Format DICOM date string (YYYYMMDD) to readable format (YYYY-MM-DD)
         * @param {string} s - DICOM date string
         * @returns {string} Formatted date or '-' if invalid
         */
        const formatDate = s => s?.length === 8 ? `${s.slice(0,4)}-${s.slice(4,6)}-${s.slice(6,8)}` : s || '-';

        /**
         * Safely get string value from DICOM dataset
         * @param {Object} ds - dicomParser dataset
         * @param {string} tag - DICOM tag (e.g., 'x00100010' for PatientName)
         * @returns {string} Tag value or empty string
         */
        const getString = (ds, tag) => { try { return ds.string(tag) || ''; } catch { return ''; }};

        /**
         * Safely get numeric value from DICOM dataset
         * @param {Object} ds - dicomParser dataset
         * @param {string} tag - DICOM tag
         * @param {number} def - Default value if tag not found
         * @returns {number} Tag value or default
         */
        const getNumber = (ds, tag, def = 0) => { try { const v = ds.string(tag); return v ? parseFloat(v) : def; } catch { return def; }};

        // =====================================================================
        // MEASUREMENT TOOL FUNCTIONS
        // Length measurement with calibration from DICOM PixelSpacing
        // =====================================================================

        /**
         * Generate a UUID v4 string
         * @returns {string} UUID v4 format string
         */
        function generateUUID() {
            return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, c => {
                const r = Math.random() * 16 | 0;
                return (c === 'x' ? r : (r & 0x3 | 0x8)).toString(16);
            });
        }

        /**
         * Get unique key for storing measurements by slice
         * @returns {string} Key combining study/series/slice for Map storage
         */
        function getMeasurementSliceKey() {
            if (!state.currentStudy || !state.currentSeries) return null;
            return `${state.currentStudy.studyInstanceUid}|${state.currentSeries.seriesInstanceUid}|${state.currentSliceIndex}`;
        }

        /**
         * Extract pixel spacing from DICOM dataset
         * Tries PixelSpacing (0028,0030) first, then ImagerPixelSpacing (0018,1164)
         * PixelSpacing format is "row\col" (backslash separated)
         *
         * @param {Object} dataSet - dicomParser dataset
         * @returns {Object|null} {row, col} spacing in mm, or null if not available
         */
        function extractPixelSpacing(dataSet) {
            // Try PixelSpacing first (most reliable for cross-sectional imaging)
            let spacingStr = getString(dataSet, 'x00280030');  // (0028,0030) Pixel Spacing

            // Fall back to ImagerPixelSpacing (common in projection radiography)
            if (!spacingStr) {
                spacingStr = getString(dataSet, 'x00181164');  // (0018,1164) Imager Pixel Spacing
            }

            if (!spacingStr) return null;

            // Parse "row\col" format (DICOM uses backslash as separator)
            const parts = spacingStr.split('\\');
            if (parts.length !== 2) return null;

            const row = parseFloat(parts[0]);
            const col = parseFloat(parts[1]);

            // Validate parsed values
            if (isNaN(row) || isNaN(col) || row <= 0 || col <= 0) return null;

            return { row, col };
        }

        /**
         * Convert screen coordinates to image coordinates
         * Accounts for canvas position, pan offset, and zoom level
         *
         * @param {number} screenX - X position in viewport
         * @param {number} screenY - Y position in viewport
         * @returns {Object} {x, y} in image pixel coordinates
         */
        function screenToImage(screenX, screenY) {
            const rect = canvas.getBoundingClientRect();
            const { panX, panY, zoom } = state.viewTransform;

            // Position relative to canvas element
            const canvasX = screenX - rect.left;
            const canvasY = screenY - rect.top;

            // Account for canvas display scaling (CSS vs actual pixels)
            const scaleX = canvas.width / rect.width;
            const scaleY = canvas.height / rect.height;

            // Convert to image coordinates, accounting for pan and zoom
            // Transform origin is center of canvas
            const centerX = canvas.width / 2;
            const centerY = canvas.height / 2;

            const imageX = (canvasX * scaleX - centerX - panX) / zoom + centerX;
            const imageY = (canvasY * scaleY - centerY - panY) / zoom + centerY;

            return { x: imageX, y: imageY };
        }

        /**
         * Convert image coordinates to overlay canvas coordinates
         * Since the overlay canvas has the same CSS transform as the image canvas,
         * we simply return the image coordinates directly.
         *
         * @param {number} imageX - X position in image pixels
         * @param {number} imageY - Y position in image pixels
         * @returns {Object} {x, y} in overlay canvas coordinates
         */
        function imageToCanvas(imageX, imageY) {
            // The overlay canvas uses the same CSS transform as the image canvas,
            // so we draw directly in image coordinates
            return { x: imageX, y: imageY };
        }

        /**
         * Calculate distance between two points
         * Handles anisotropic pixels (different row/col spacing)
         *
         * @param {Object} start - {x, y} start point in image coordinates
         * @param {Object} end - {x, y} end point in image coordinates
         * @param {Object|null} pixelSpacing - {row, col} in mm, or null
         * @returns {Object} {distancePixels, distanceMm}
         */
        function calculateDistance(start, end, pixelSpacing) {
            const dx = end.x - start.x;
            const dy = end.y - start.y;

            // Distance in pixels (always available)
            const distancePixels = Math.sqrt(dx * dx + dy * dy);

            // Distance in mm (only if calibrated)
            let distanceMm = null;
            if (pixelSpacing) {
                // Use col spacing for X, row spacing for Y (DICOM convention)
                const dxMm = dx * pixelSpacing.col;
                const dyMm = dy * pixelSpacing.row;
                distanceMm = Math.sqrt(dxMm * dxMm + dyMm * dyMm);
            }

            return { distancePixels, distanceMm };
        }

        /**
         * Format distance for display
         * Uses mm for < 100mm, cm for >= 100mm
         * Falls back to pixels if uncalibrated
         *
         * @param {number|null} distanceMm - Distance in mm, or null
         * @param {number} distancePixels - Distance in pixels
         * @returns {string} Formatted distance string
         */
        function formatDistance(distanceMm, distancePixels) {
            if (distanceMm !== null) {
                if (distanceMm >= 100) {
                    return (distanceMm / 10).toFixed(2) + ' cm';
                }
                return distanceMm.toFixed(2) + ' mm';
            }
            return distancePixels.toFixed(1) + ' px';
        }

        /**
         * Create a new measurement object (persistence-ready structure)
         *
         * @param {Object} start - {x, y} start point
         * @param {Object} end - {x, y} end point
         * @returns {Object} Measurement object
         */
        function createMeasurement(start, end) {
            const { distancePixels, distanceMm } = calculateDistance(start, end, state.pixelSpacing);

            return {
                id: generateUUID(),
                type: 'length',
                studyInstanceUid: state.currentStudy?.studyInstanceUid || null,
                seriesInstanceUid: state.currentSeries?.seriesInstanceUid || null,
                sliceIndex: state.currentSliceIndex,
                sopInstanceUid: null,  // Could be extracted from current slice if needed
                points: [
                    { x: start.x, y: start.y },
                    { x: end.x, y: end.y }
                ],
                distanceMm: distanceMm,
                distancePixels: distancePixels,
                createdAt: new Date().toISOString(),
                label: null
            };
        }

        /**
         * Get measurements for current slice
         * @returns {Array} Array of measurements for current slice
         */
        function getCurrentSliceMeasurements() {
            const key = getMeasurementSliceKey();
            if (!key) return [];
            return state.measurements.get(key) || [];
        }

        /**
         * Add a measurement to the current slice
         * @param {Object} measurement - Measurement object to add
         */
        function addMeasurement(measurement) {
            const key = getMeasurementSliceKey();
            if (!key) return;

            const sliceMeasurements = state.measurements.get(key) || [];
            sliceMeasurements.push(measurement);
            state.measurements.set(key, sliceMeasurements);
        }

        /**
         * Delete a measurement by ID from the current slice
         * @param {string} measurementId - ID of measurement to delete
         * @returns {boolean} True if measurement was found and deleted
         */
        function deleteMeasurement(measurementId) {
            const key = getMeasurementSliceKey();
            if (!key) return false;

            const sliceMeasurements = state.measurements.get(key) || [];
            const index = sliceMeasurements.findIndex(m => m.id === measurementId);
            if (index === -1) return false;

            sliceMeasurements.splice(index, 1);
            state.measurements.set(key, sliceMeasurements);
            drawMeasurements();
            return true;
        }

        /**
         * Delete the most recent measurement on current slice
         * @returns {boolean} True if a measurement was deleted
         */
        function deleteLastMeasurement() {
            const key = getMeasurementSliceKey();
            if (!key) return false;

            const sliceMeasurements = state.measurements.get(key) || [];
            if (sliceMeasurements.length === 0) return false;

            sliceMeasurements.pop();
            state.measurements.set(key, sliceMeasurements);
            drawMeasurements();
            return true;
        }

        /**
         * Clear all measurements on current slice
         * @returns {boolean} True if measurements were cleared
         */
        function clearSliceMeasurements() {
            const key = getMeasurementSliceKey();
            if (!key) return false;

            const sliceMeasurements = state.measurements.get(key) || [];
            if (sliceMeasurements.length === 0) return false;

            state.measurements.delete(key);
            drawMeasurements();
            return true;
        }

        /**
         * Find measurement at given image coordinates (hit testing)
         * Returns the measurement if click is within tolerance of the line or endpoints
         *
         * @param {number} imageX - X position in image coordinates
         * @param {number} imageY - Y position in image coordinates
         * @param {number} tolerance - Hit detection tolerance in pixels (default 8)
         * @returns {Object|null} Measurement object if found, null otherwise
         */
        function findMeasurementAtPoint(imageX, imageY, tolerance = 8) {
            const measurements = getCurrentSliceMeasurements();

            // Check in reverse order so most recent measurements are hit first
            for (let i = measurements.length - 1; i >= 0; i--) {
                const m = measurements[i];
                if (!m.points || m.points.length < 2) continue;

                const start = m.points[0];
                const end = m.points[1];

                // Check endpoints first (easier click targets)
                if (Math.hypot(imageX - start.x, imageY - start.y) <= tolerance) return m;
                if (Math.hypot(imageX - end.x, imageY - end.y) <= tolerance) return m;

                // Check distance to line segment
                if (pointToLineDistance(imageX, imageY, start.x, start.y, end.x, end.y) <= tolerance) {
                    return m;
                }
            }

            return null;
        }

        /**
         * Calculate shortest distance from point to line segment
         * @param {number} px - Point X
         * @param {number} py - Point Y
         * @param {number} x1 - Line start X
         * @param {number} y1 - Line start Y
         * @param {number} x2 - Line end X
         * @param {number} y2 - Line end Y
         * @returns {number} Distance in pixels
         */
        function pointToLineDistance(px, py, x1, y1, x2, y2) {
            const dx = x2 - x1;
            const dy = y2 - y1;
            const lengthSq = dx * dx + dy * dy;

            // Line segment is a point
            if (lengthSq === 0) return Math.hypot(px - x1, py - y1);

            // Project point onto line, clamped to segment [0, 1]
            const t = Math.max(0, Math.min(1, ((px - x1) * dx + (py - y1) * dy) / lengthSq));

            // Distance to closest point on segment
            return Math.hypot(px - (x1 + t * dx), py - (y1 + t * dy));
        }

        /**
         * Sync measurement overlay canvas size and position with image canvas
         * Applies the same CSS transform so measurements move with the image
         */
        function syncMeasurementCanvas() {
            // Match the image canvas dimensions
            measurementCanvas.width = canvas.width;
            measurementCanvas.height = canvas.height;

            // Copy the same CSS styles as the image canvas
            measurementCanvas.style.maxWidth = '100%';
            measurementCanvas.style.maxHeight = '100%';

            // Apply the same transform as the image canvas
            const { panX, panY, zoom } = state.viewTransform;
            measurementCanvas.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
            measurementCanvas.style.transformOrigin = 'center center';
        }

        /**
         * Draw all measurements on the overlay canvas
         * Called after view transform changes or measurements added
         */
        function drawMeasurements() {
            if (!measurementCanvas) return;

            // Sync canvas size/position first
            syncMeasurementCanvas();

            // Clear the overlay
            measureCtx.clearRect(0, 0, measurementCanvas.width, measurementCanvas.height);

            // Get measurements for current slice
            const measurements = getCurrentSliceMeasurements();

            // Draw each measurement
            for (const m of measurements) {
                drawSingleMeasurement(m);
            }

            // Draw active measurement (being drawn)
            if (state.activeMeasurement) {
                drawSingleMeasurement(state.activeMeasurement, true);
            }
        }

        /**
         * Draw a single measurement line with label
         *
         * @param {Object} measurement - Measurement object
         * @param {boolean} isActive - Whether this is the measurement being drawn
         */
        function drawSingleMeasurement(measurement, isActive = false) {
            if (!measurement.points || measurement.points.length < 2) return;

            const start = measurement.points[0];
            const end = measurement.points[1];

            // Convert to canvas coordinates (accounting for pan/zoom)
            const startCanvas = imageToCanvas(start.x, start.y);
            const endCanvas = imageToCanvas(end.x, end.y);

            // Line style
            measureCtx.strokeStyle = isActive ? '#ffcc00' : '#00ff00';
            measureCtx.lineWidth = 2;
            measureCtx.lineCap = 'round';

            // Draw line
            measureCtx.beginPath();
            measureCtx.moveTo(startCanvas.x, startCanvas.y);
            measureCtx.lineTo(endCanvas.x, endCanvas.y);
            measureCtx.stroke();

            // Draw endpoints (small circles)
            const endpointRadius = 4;
            measureCtx.fillStyle = isActive ? '#ffcc00' : '#00ff00';

            measureCtx.beginPath();
            measureCtx.arc(startCanvas.x, startCanvas.y, endpointRadius, 0, Math.PI * 2);
            measureCtx.fill();

            measureCtx.beginPath();
            measureCtx.arc(endCanvas.x, endCanvas.y, endpointRadius, 0, Math.PI * 2);
            measureCtx.fill();

            // Draw label near the midpoint, offset to avoid overlapping the line
            const midX = (startCanvas.x + endCanvas.x) / 2;
            const midY = (startCanvas.y + endCanvas.y) / 2;

            // Calculate perpendicular offset for label placement
            const dx = endCanvas.x - startCanvas.x;
            const dy = endCanvas.y - startCanvas.y;
            const length = Math.sqrt(dx * dx + dy * dy);
            const offsetDist = 15;  // Pixels away from line

            // Perpendicular direction (normalized), prefer above the line
            let perpX = -dy / length;
            let perpY = dx / length;
            if (perpY > 0) { perpX = -perpX; perpY = -perpY; }  // Prefer label above

            const labelX = midX + perpX * offsetDist;
            const labelY = midY + perpY * offsetDist;

            // Format distance text
            const distanceText = formatDistance(measurement.distanceMm, measurement.distancePixels);

            // Draw text with background for readability
            measureCtx.font = '12px -apple-system, BlinkMacSystemFont, sans-serif';
            const textMetrics = measureCtx.measureText(distanceText);
            const textWidth = textMetrics.width;
            const textHeight = 14;
            const padding = 4;

            // Background rectangle
            measureCtx.fillStyle = 'rgba(0, 0, 0, 0.7)';
            measureCtx.fillRect(
                labelX - textWidth / 2 - padding,
                labelY - textHeight / 2 - padding,
                textWidth + padding * 2,
                textHeight + padding * 2
            );

            // Text
            measureCtx.fillStyle = isActive ? '#ffcc00' : '#00ff00';
            measureCtx.textAlign = 'center';
            measureCtx.textBaseline = 'middle';
            measureCtx.fillText(distanceText, labelX, labelY);
        }

        /**
         * Update calibration warning display
         */
        function updateCalibrationWarning() {
            if (state.currentTool === 'measure') {
                calibrationWarning.style.display = state.pixelSpacing ? 'none' : 'inline';
            } else {
                calibrationWarning.style.display = 'none';
            }
        }

        // =====================================================================
        // DICOM PARSING
        // =====================================================================

        /**
         * Parse DICOM file metadata without loading pixel data (fast scan)
         * Used during folder import to organize files by study/series.
         *
         * @param {File} file - File object from File System Access API
         * @returns {Promise<Object|null>} Metadata object or null if not valid DICOM
         */
        async function parseDicomMetadata(file) {
            try {
                const arrayBuffer = await file.arrayBuffer();
                const byteArray = new Uint8Array(arrayBuffer);
                const dataSet = dicomParser.parseDicom(byteArray, { untilTag: 'x7fe00010' });
                const transferSyntax = getString(dataSet, 'x00020010');
                return {
                    patientName: getString(dataSet, 'x00100010'),
                    studyDate: getString(dataSet, 'x00080020'),
                    studyDescription: getString(dataSet, 'x00081030'),
                    studyInstanceUid: getString(dataSet, 'x0020000d'),
                    seriesDescription: getString(dataSet, 'x0008103e'),
                    seriesInstanceUid: getString(dataSet, 'x0020000e'),
                    seriesNumber: getString(dataSet, 'x00200011'),
                    modality: getString(dataSet, 'x00080060'),
                    instanceNumber: getNumber(dataSet, 'x00200013', 0),
                    sliceLocation: getNumber(dataSet, 'x00201041', 0),
                    transferSyntax: transferSyntax,
                };
            } catch { return null; }
        }

        // =====================================================================
        // FILE SYSTEM OPERATIONS
        // Uses File System Access API (Chrome/Edge only)
        // =====================================================================

        /**
         * Recursively get all file handles from a directory
         * @param {FileSystemDirectoryHandle} dirHandle - Directory handle from drop event
         * @param {string} path - Current path (for recursion)
         * @returns {Promise<Array>} Array of {handle, name} objects
         */
        async function getAllFileHandles(dirHandle, path = '') {
            const files = [];
            for await (const [name, handle] of dirHandle.entries()) {
                if (handle.kind === 'file') {
                    files.push({ handle, name });
                } else if (handle.kind === 'directory') {
                    files.push(...await getAllFileHandles(handle, path + name + '/'));
                }
            }
            return files;
        }

        /**
         * Process array of file handles into organized study/series structure
         * Parses each DICOM file's metadata and groups by StudyInstanceUID/SeriesInstanceUID
         *
         * @param {Array} fileHandles - Array of {handle, name} objects
         * @returns {Promise<Object>} Map of studyInstanceUid -> study data
         */
        async function processFiles(fileHandles) {
            const studies = {};
            const total = fileHandles.length;
            let processed = 0, valid = 0;

            const batchSize = 100;
            for (let i = 0; i < fileHandles.length; i += batchSize) {
                const batch = fileHandles.slice(i, i + batchSize);
                await Promise.all(batch.map(async ({ handle }) => {
                    const file = await handle.getFile();
                    const meta = await parseDicomMetadata(file);
                    processed++;

                    if (processed % 200 === 0 || processed === total) {
                        const pct = Math.round((processed / total) * 100);
                        progressFill.style.width = pct + '%';
                        progressText.textContent = `Scanning... ${pct}%`;
                        progressDetail.textContent = `${processed}/${total} files (${valid} DICOM)`;
                    }

                    if (!meta?.studyInstanceUid) return;
                    valid++;

                    const studyUid = meta.studyInstanceUid;
                    const seriesUid = meta.seriesInstanceUid || 'default';

                    if (!studies[studyUid]) {
                        studies[studyUid] = {
                            ...meta, series: {}, seriesCount: 0, imageCount: 0
                        };
                    }
                    if (!studies[studyUid].series[seriesUid]) {
                        studies[studyUid].series[seriesUid] = {
                            seriesInstanceUid: seriesUid,
                            seriesDescription: meta.seriesDescription,
                            seriesNumber: meta.seriesNumber,
                            transferSyntax: meta.transferSyntax,
                            slices: []
                        };
                    }
                    studies[studyUid].series[seriesUid].slices.push({
                        fileHandle: handle,
                        instanceNumber: meta.instanceNumber,
                        sliceLocation: meta.sliceLocation
                    });
                }));
            }

            // Sort and count
            for (const study of Object.values(studies)) {
                let count = 0;
                for (const series of Object.values(study.series)) {
                    series.slices.sort((a, b) => a.instanceNumber - b.instanceNumber || a.sliceLocation - b.sliceLocation);
                    count += series.slices.length;
                }
                study.seriesCount = Object.keys(study.series).length;
                study.imageCount = count;
            }
            return studies;
        }

        // =====================================================================
        // COMMENTS SYSTEM
        // Allows users to add notes to studies and series (stored in memory)
        // =====================================================================

        /**
         * Format Unix timestamp to human-readable date/time
         * @param {number} date - Unix timestamp in milliseconds
         * @returns {string} Formatted date string
         */
        function formatTimestamp(date) {
            return new Date(date).toLocaleString('en-US', {
                month: 'short', day: 'numeric', year: 'numeric',
                hour: 'numeric', minute: '2-digit', hour12: true
            });
        }

        function normalizeCommentId(value) {
            if (value === null || value === undefined) return null;
            const asNumber = Number(value);
            if (!Number.isNaN(asNumber)) return asNumber;
            return String(value);
        }

        function findCommentIndex(comments, commentId) {
            const target = normalizeCommentId(commentId);
            if (target === null) return -1;
            return comments.findIndex(c => normalizeCommentId(c.id) === target);
        }

        function generateLocalCommentId() {
            return `local-${crypto.randomUUID()}`;
        }

        // Render comments list HTML
        function renderComments(comments, studyUid, seriesUid = null) {
            if (!comments || comments.length === 0) return '';
            return comments.map(c => `
                <div class="comment-item" data-comment-id="${escapeHtml(c.id)}">
                    <div class="comment-header">
                        <span class="comment-time">${formatTimestamp(c.time)}</span>
                        <span class="comment-actions">
                            <button class="comment-btn edit-comment" data-study-uid="${escapeHtml(studyUid)}" ${seriesUid ? `data-series-uid="${escapeHtml(seriesUid)}"` : ''} data-comment-id="${escapeHtml(c.id)}">Edit</button>
                            <button class="comment-btn delete-comment" data-study-uid="${escapeHtml(studyUid)}" ${seriesUid ? `data-series-uid="${escapeHtml(seriesUid)}"` : ''} data-comment-id="${escapeHtml(c.id)}">Delete</button>
                        </span>
                    </div>
                    <div class="comment-text">${escapeHtml(c.text)}</div>
                </div>
            `).join('');
        }

        // Track open panels
        const openPanels = {
            studyPanels: new Set(),
            seriesPanels: new Set(),
            seriesDropdowns: new Set()
        };

        const descriptionSaveTimers = new Map();

        function scheduleDescriptionSave(key, callback) {
            const existing = descriptionSaveTimers.get(key);
            if (existing) clearTimeout(existing);
            const handle = setTimeout(() => {
                descriptionSaveTimers.delete(key);
                callback();
            }, 500);
            descriptionSaveTimers.set(key, handle);
        }

        // Update just the comment list without re-rendering everything
        function updateCommentListUI(studyUid, seriesUid) {
            const comments = seriesUid
                ? state.studies[studyUid].series[seriesUid].comments
                : state.studies[studyUid].comments;

            // Find the comment list element
            let commentList;
            if (seriesUid) {
                const panel = document.querySelector(`.series-comment-panel[data-study-uid="${CSS.escape(studyUid)}"][data-series-uid="${CSS.escape(seriesUid)}"]`);
                commentList = panel?.querySelector('.comment-list');
            } else {
                const panel = document.querySelector(`.comment-panel-row[data-study-uid="${CSS.escape(studyUid)}"]`);
                commentList = panel?.querySelector('.comment-list');
            }

            if (commentList) {
                commentList.innerHTML = renderComments(comments, studyUid, seriesUid);
                // Re-attach edit/delete handlers
                commentList.querySelectorAll('.edit-comment').forEach(btn => {
                    btn.onclick = (e) => {
                        e.stopPropagation();
                        editComment(btn.dataset.studyUid, btn.dataset.seriesUid || null, btn.dataset.commentId);
                    };
                });
                commentList.querySelectorAll('.delete-comment').forEach(btn => {
                    btn.onclick = (e) => {
                        e.stopPropagation();
                        deleteComment(btn.dataset.studyUid, btn.dataset.seriesUid || null, btn.dataset.commentId);
                    };
                });
            }

            // Update the button text
            const count = comments.length;
            let btn;
            if (seriesUid) {
                btn = document.querySelector(`.series-comment-toggle[data-study-uid="${CSS.escape(studyUid)}"][data-series-uid="${CSS.escape(seriesUid)}"]`);
            } else {
                btn = document.querySelector(`.comment-toggle[data-study-uid="${CSS.escape(studyUid)}"]:not(.series-comment-toggle)`);
            }
            // Keep showing "Hide comments" if panel is open
            if (btn && btn.textContent !== 'Hide comments') {
                btn.textContent = count > 0 ? `${count} comment${count > 1 ? 's' : ''}` : 'Add comment';
            }

            // Clear the input
            let input;
            if (seriesUid) {
                input = document.querySelector(`.add-series-comment[data-study-uid="${CSS.escape(studyUid)}"][data-series-uid="${CSS.escape(seriesUid)}"]`);
            } else {
                input = document.querySelector(`.add-study-comment[data-study-uid="${CSS.escape(studyUid)}"]`);
            }
            if (input) input.value = '';
        }

        // Add comment to study or series
        async function addComment(studyUid, seriesUid, text) {
            if (!text.trim()) return;
            const now = Date.now();
            const comment = { id: generateLocalCommentId(), text: text.trim(), time: now };
            let comments;
            if (seriesUid) {
                if (!Array.isArray(state.studies[studyUid].series[seriesUid].comments)) {
                    state.studies[studyUid].series[seriesUid].comments = [];
                }
                comments = state.studies[studyUid].series[seriesUid].comments;
            } else {
                if (!Array.isArray(state.studies[studyUid].comments)) {
                    state.studies[studyUid].comments = [];
                }
                comments = state.studies[studyUid].comments;
            }

            comments.push(comment);
            updateCommentListUI(studyUid, seriesUid);

            const saved = await NotesAPI.addComment(studyUid, {
                text: comment.text,
                time: comment.time,
                seriesUid: seriesUid
            });
            if (saved?.id !== undefined && saved?.id !== null) {
                comment.id = saved.id;
                updateCommentListUI(studyUid, seriesUid);
            }
        }

        // Delete comment
        async function deleteComment(studyUid, seriesUid, commentId) {
            const comments = seriesUid
                ? state.studies[studyUid].series[seriesUid].comments
                : state.studies[studyUid].comments;
            if (!Array.isArray(comments)) return;
            const idx = findCommentIndex(comments, commentId);
            if (idx === -1) return;
            comments.splice(idx, 1);
            updateCommentListUI(studyUid, seriesUid);
            if (!String(commentId).startsWith('local-')) {
                await NotesAPI.deleteComment(studyUid, commentId);
            }
        }

        // Edit comment
        async function editComment(studyUid, seriesUid, commentId) {
            const comments = seriesUid
                ? state.studies[studyUid].series[seriesUid].comments
                : state.studies[studyUid].comments;
            if (!Array.isArray(comments)) return;
            const idx = findCommentIndex(comments, commentId);
            if (idx === -1) return;
            const newText = prompt('Edit comment:', comments[idx].text);
            if (newText !== null && newText.trim()) {
                comments[idx].text = newText.trim();
                comments[idx].time = Date.now();
                updateCommentListUI(studyUid, seriesUid);
                if (!String(commentId).startsWith('local-')) {
                    await NotesAPI.updateComment(studyUid, commentId, {
                    text: comments[idx].text,
                    time: comments[idx].time
                    });
                }
            }
        }

        // =====================================================================
        // NOTES PERSISTENCE (SERVER-SIDE)
        // =====================================================================

        const MIGRATION_FLAG_KEY = 'dicom-viewer-migrated';
        const LEGACY_STORAGE_KEY = 'dicom-viewer-comments';
        const LEGACY_REPORTS_DB = 'dicom-viewer-reports';
        const LEGACY_REPORTS_STORE = 'reports';

        async function loadNotesForStudies() {
            const studyUids = Object.keys(state.studies);
            if (!studyUids.length) return;

            const result = await NotesAPI.loadNotes(studyUids);
            const notes = result?.studies || {};

            for (const [studyUid, entry] of Object.entries(notes)) {
                const study = state.studies[studyUid];
                if (!study) continue;

                if (entry.description !== undefined) {
                    study.description = entry.description || '';
                }
                if (Array.isArray(entry.comments)) {
                    study.comments = entry.comments;
                    study.comments.forEach(c => {
                        if (c.id === undefined || c.id === null) {
                            c.id = generateLocalCommentId();
                        }
                    });
                }
                if (Array.isArray(entry.reports)) {
                    study.reports = entry.reports;
                }

                if (entry.series && typeof entry.series === 'object') {
                    for (const [seriesUid, seriesEntry] of Object.entries(entry.series)) {
                        const series = study.series[seriesUid];
                        if (!series) continue;
                        if (seriesEntry.description !== undefined) {
                            series.description = seriesEntry.description || '';
                        }
                        if (Array.isArray(seriesEntry.comments)) {
                            series.comments = seriesEntry.comments;
                            series.comments.forEach(c => {
                                if (c.id === undefined || c.id === null) {
                                    c.id = generateLocalCommentId();
                                }
                            });
                        }
                    }
                }
            }
        }

        async function openLegacyReportsDB() {
            if (!('indexedDB' in window)) return null;
            return new Promise((resolve) => {
                const request = indexedDB.open(LEGACY_REPORTS_DB, 1);
                request.onerror = () => resolve(null);
                request.onsuccess = () => {
                    const db = request.result;
                    if (!db.objectStoreNames.contains(LEGACY_REPORTS_STORE)) {
                        db.close();
                        resolve(null);
                        return;
                    }
                    resolve(db);
                };
                request.onupgradeneeded = () => resolve(null);
            });
        }

        async function getLegacyReportBlob(db, reportId) {
            if (!db) return null;
            return new Promise((resolve) => {
                const tx = db.transaction(LEGACY_REPORTS_STORE, 'readonly');
                const request = tx.objectStore(LEGACY_REPORTS_STORE).get(reportId);
                request.onsuccess = () => resolve(request.result?.blob || null);
                request.onerror = () => resolve(null);
            });
        }

        async function migrateIfNeeded() {
            if (!NotesAPI.isEnabled()) return;
            if (typeof CONFIG !== 'undefined' && !CONFIG.features.notesServer) return;
            let alreadyMigrated = false;
            try {
                alreadyMigrated = !!localStorage.getItem(MIGRATION_FLAG_KEY);
            } catch (e) {
                return;
            }
            if (alreadyMigrated) return;

            let raw;
            try {
                raw = localStorage.getItem(LEGACY_STORAGE_KEY);
            } catch (e) {
                return;
            }
            if (!raw) {
                localStorage.setItem(MIGRATION_FLAG_KEY, '1');
                return;
            }

            let payload;
            try {
                payload = JSON.parse(raw);
            } catch (e) {
                console.warn('Failed to parse legacy notes for migration:', e);
                return;
            }

            const migrated = await NotesAPI.migrate(payload);
            if (!migrated) return;

            if (payload?.version === 2 && payload?.comments) {
                const db = await openLegacyReportsDB();
                const uploadTasks = [];
                for (const [studyUid, stored] of Object.entries(payload.comments)) {
                    const reports = stored?.reports || [];
                    for (const report of reports) {
                        if (!report?.id) continue;
                        uploadTasks.push((async () => {
                            const blob = await getLegacyReportBlob(db, report.id);
                            if (!blob) return;
                            const filename = report.name || 'report';
                            const file = new File([blob], filename, { type: blob.type || '' });
                            await NotesAPI.uploadReport(studyUid, file, report);
                        })());
                    }
                }
                if (db) db.close();

                // Only set migration flag if all report uploads succeeded.
                // If any failed, omitting the flag allows retry on next load.
                if (uploadTasks.length) {
                    const results = await Promise.allSettled(uploadTasks);
                    if (results.every(r => r.status === 'fulfilled')) {
                        localStorage.setItem(MIGRATION_FLAG_KEY, '1');
                    }
                    return;
                }
            }

            localStorage.setItem(MIGRATION_FLAG_KEY, '1');
        }

        // =====================================================================
        // REPORTS SYSTEM
        // Allows users to attach PDF and image reports to studies
        // =====================================================================

        /**
         * Escape a string for safe insertion into innerHTML
         * @param {string} str - Untrusted string
         * @returns {string} HTML-safe string
         */
        function escapeHtml(str) {
            if (str == null) return '';
            return String(str)
                .replace(/&/g, '&amp;')
                .replace(/</g, '&lt;')
                .replace(/>/g, '&gt;')
                .replace(/"/g, '&quot;')
                .replace(/'/g, '&#39;');
        }

        /**
         * Get file type from MIME type with filename extension fallback
         * @param {File} file - File object
         * @returns {'pdf'|'png'|'jpg'|null}
         */
        function getReportType(file) {
            const mime = file.type;
            if (mime === 'application/pdf') return 'pdf';
            if (mime === 'image/png') return 'png';
            if (mime === 'image/jpeg') return 'jpg';

            // Fallback to extension when MIME is absent or generic
            const ext = file.name.toLowerCase().split('.').pop();
            if (ext === 'pdf') return 'pdf';
            if (ext === 'png') return 'png';
            if (ext === 'jpg' || ext === 'jpeg') return 'jpg';
            return null;
        }

        /**
         * Format file size for display
         * @param {number} bytes
         * @returns {string}
         */
        function formatFileSize(bytes) {
            if (bytes < 1024) return bytes + ' B';
            if (bytes < 1024 * 1024) return (bytes / 1024).toFixed(1) + ' KB';
            return (bytes / (1024 * 1024)).toFixed(1) + ' MB';
        }

        /**
         * Add a report to a study
         * @param {string} studyUid - Study instance UID
         * @param {File} file - File object from input
         */
        async function addReport(studyUid, file) {
            const type = getReportType(file);
            if (!type) {
                alert('Unsupported file type. Please use PDF, PNG, or JPG.');
                return;
            }

            if (!state.studies[studyUid].reports) {
                state.studies[studyUid].reports = [];
            }

            const now = Date.now();

            const report = {
                id: generateUUID(),
                name: file.name,
                type: type,
                size: file.size,
                addedAt: now,
                updatedAt: now,
                blob: null
            };

            const saved = await NotesAPI.uploadReport(studyUid, file, report);
            if (saved) {
                Object.assign(report, saved);
            } else {
                // Server unavailable; keep in-memory blob for this session
                report.blob = file;
            }

            state.studies[studyUid].reports.push(report);
            updateReportListUI(studyUid);
        }

        /**
         * Delete a report from a study
         * @param {string} studyUid - Study instance UID
         * @param {string} reportId - Report UUID
         */
        async function deleteReport(studyUid, reportId) {
            const reports = state.studies[studyUid].reports;
            if (!reports) return;
            const idx = reports.findIndex(r => r.id === reportId);
            if (idx === -1) return;

            const removed = reports.splice(idx, 1)[0];
            updateReportListUI(studyUid);

            const result = await NotesAPI.deleteReport(studyUid, reportId);
            if (!result && NotesAPI.isEnabled()) {
                // Server failed -- restore the report in the UI
                reports.splice(idx, 0, removed);
                updateReportListUI(studyUid);
                alert('Failed to delete report. Please try again.');
            }
        }

        /**
         * Render reports list HTML
         * @param {Array} reports - Array of report objects
         * @param {string} studyUid - Study instance UID
         * @returns {string} HTML string
         */
        function renderReports(reports, studyUid) {
            if (!reports || reports.length === 0) {
                return '<p class="report-empty">No reports attached</p>';
            }

            return reports.map(r => {
                const icon = r.type === 'pdf' ? '&#128196;' : '&#128247;';

                return `
                    <div class="report-item" data-report-id="${escapeHtml(r.id)}">
                        <span class="report-icon">${icon}</span>
                        <span class="report-name">${escapeHtml(r.name)}</span>
                        <span class="report-size">${formatFileSize(r.size)}</span>
                        <span class="report-actions">
                            <button class="report-btn view-report" data-study-uid="${escapeHtml(studyUid)}" data-report-id="${escapeHtml(r.id)}">View</button>
                            <button class="report-btn delete-report" data-study-uid="${escapeHtml(studyUid)}" data-report-id="${escapeHtml(r.id)}">Delete</button>
                        </span>
                    </div>
                `;
            }).join('');
        }

        /**
         * Update report list UI without full page re-render
         * @param {string} studyUid - Study instance UID
         */
        function updateReportListUI(studyUid) {
            const reportList = document.querySelector(`.report-list[data-study-uid="${CSS.escape(studyUid)}"]`);
            if (reportList) {
                reportList.innerHTML = renderReports(state.studies[studyUid].reports, studyUid);
                attachReportEventHandlers(studyUid);
            }

            // Update button text
            const btn = document.querySelector(`.report-toggle[data-study-uid="${CSS.escape(studyUid)}"]`);
            if (btn) {
                const count = state.studies[studyUid].reports?.length || 0;
                btn.textContent = count > 0 ? `${count} report${count > 1 ? 's' : ''}` : 'Add report';
            }
        }

        /**
         * Open report in viewer modal
         * @param {string} studyUid - Study instance UID
         * @param {string} reportId - Report UUID
         */
        async function viewReport(studyUid, reportId) {
            const report = state.studies[studyUid].reports?.find(r => r.id === reportId);
            if (!report) return;

            const viewer = $('reportViewer');
            const pdfFrame = $('reportPdfFrame');
            const imageView = $('reportImageView');
            const title = $('reportViewerTitle');

            // Cleanup previous object URL (used for in-memory fallback)
            if (viewer.dataset.objectUrl) {
                URL.revokeObjectURL(viewer.dataset.objectUrl);
                delete viewer.dataset.objectUrl;
            }

            let url = '';
            if (report.blob) {
                url = URL.createObjectURL(report.blob);
                viewer.dataset.objectUrl = url;
            } else {
                url = NotesAPI.getReportFileUrl(report.id);
            }

            if (!url) {
                alert('Report file not available.');
                return;
            }

            // Hide both viewers initially
            pdfFrame.style.display = 'none';
            imageView.style.display = 'none';

            title.textContent = report.name;

            if (report.type === 'pdf') {
                pdfFrame.src = url;
                pdfFrame.style.display = 'block';
            } else {
                imageView.src = url;
                imageView.style.display = 'block';
            }

            viewer.style.display = 'flex';
        }

        /**
         * Close report viewer and cleanup resources
         */
        function closeReportViewer() {
            const viewer = $('reportViewer');
            const pdfFrame = $('reportPdfFrame');
            const imageView = $('reportImageView');

            // Cleanup object URL to prevent memory leak
            if (viewer.dataset.objectUrl) {
                URL.revokeObjectURL(viewer.dataset.objectUrl);
                delete viewer.dataset.objectUrl;
            }

            pdfFrame.src = '';
            imageView.src = '';
            viewer.style.display = 'none';
        }

        // =====================================================================
        // HELP VIEWER
        // In-app user guide modal with table of contents and scroll sync
        // =====================================================================

        /**
         * Highlight active help section in table of contents
         * @param {string} sectionId - HELP_SECTIONS id value
         */
        function setActiveHelpTocItem(sectionId) {
            document.querySelectorAll('.help-toc-item').forEach(item => {
                item.classList.toggle('active', item.dataset.sectionId === sectionId);
            });
        }

        /**
         * Update active TOC entry as user scrolls help content
         */
        function onHelpContentScroll() {
            const contentEl = $('helpContent');
            if (!contentEl) return;

            const sections = Array.from(contentEl.querySelectorAll('.help-section'));
            if (!sections.length) return;

            const offset = contentEl.scrollTop + 40;
            let activeSectionId = sections[0].dataset.sectionId;

            for (const section of sections) {
                if (section.offsetTop <= offset) {
                    activeSectionId = section.dataset.sectionId;
                } else {
                    break;
                }
            }

            setActiveHelpTocItem(activeSectionId);
        }

        /**
         * Build help table of contents and section content from HELP_SECTIONS
         */
        function renderHelpContent() {
            const tocEl = $('helpToc');
            const contentEl = $('helpContent');
            if (!tocEl || !contentEl || !Array.isArray(HELP_SECTIONS)) return;

            tocEl.innerHTML = HELP_SECTIONS.map(section => `
                <a href="#help-${escapeHtml(section.id)}" class="help-toc-item" data-section-id="${escapeHtml(section.id)}">
                    ${escapeHtml(section.title)}
                </a>
            `).join('');

            contentEl.innerHTML = HELP_SECTIONS.map(section => `
                <section id="help-${escapeHtml(section.id)}" class="help-section" data-section-id="${escapeHtml(section.id)}">
                    <h2>${escapeHtml(section.title)}</h2>
                    ${section.content}
                </section>
            `).join('');

            tocEl.querySelectorAll('.help-toc-item').forEach(item => {
                item.addEventListener('click', e => {
                    e.preventDefault();
                    const sectionId = item.dataset.sectionId;
                    const target = contentEl.querySelector(`#help-${CSS.escape(sectionId)}`);
                    if (!target) return;
                    target.scrollIntoView({ behavior: 'smooth', block: 'start' });
                    setActiveHelpTocItem(sectionId);
                });
            });

            contentEl.removeEventListener('scroll', onHelpContentScroll);
            contentEl.addEventListener('scroll', onHelpContentScroll);
            onHelpContentScroll();
        }

        /**
         * Open in-app help modal
         */
        function openHelpViewer() {
            $('helpViewer').style.display = 'flex';
            renderHelpContent();
            const contentEl = $('helpContent');
            if (contentEl) contentEl.scrollTop = 0;
            onHelpContentScroll();
        }

        /**
         * Close in-app help modal
         */
        function closeHelpViewer() {
            $('helpViewer').style.display = 'none';
        }

        /**
         * Attach event handlers for report actions within a study
         * @param {string} studyUid - Study instance UID
         */
        function attachReportEventHandlers(studyUid) {
            // View report buttons
            document.querySelectorAll(`.view-report[data-study-uid="${CSS.escape(studyUid)}"]`).forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    viewReport(studyUid, btn.dataset.reportId);
                };
            });

            // Delete report buttons
            document.querySelectorAll(`.delete-report[data-study-uid="${CSS.escape(studyUid)}"]`).forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    if (confirm('Delete this report?')) {
                        deleteReport(studyUid, btn.dataset.reportId);
                    }
                };
            });
        }

        // =====================================================================
        // LIBRARY VIEW (STUDIES TABLE)
        // Renders the main studies list with expandable series rows
        // =====================================================================

        /**
         * Render the studies table in the library view
         * Creates expandable rows for each study with nested series items
         */
        async function displayStudies() {
            // Migrate legacy notes once, then load persisted notes from the server
            await migrateIfNeeded();
            await loadNotesForStudies();

            const studies = Object.values(state.studies);
            if (!studies.length) {
                emptyState.style.display = 'block';
                studiesTable.style.display = 'none';
                studyCount.textContent = '';
                return;
            }
            emptyState.style.display = 'none';
            studiesTable.style.display = 'table';
            studyCount.textContent = `(${studies.length})`;

            let html = '';
            for (const s of studies) {
                const seriesArr = Object.values(s.series);
                if (!Array.isArray(s.comments)) s.comments = [];
                const commentCount = s.comments.length;
                const reportCount = s.reports?.length || 0;

                html += `
                    <tr class="study-row" data-uid="${escapeHtml(s.studyInstanceUid)}">
                        <td class="expand-cell"><span class="expand-icon">&#9654;</span></td>
                        <td>${escapeHtml(s.patientName || '-')}</td>
                        <td>${formatDate(s.studyDate)}</td>
                        <td>${escapeHtml(s.studyDescription || '-')}</td>
                        <td><span class="modality-badge">${escapeHtml(s.modality || '-')}</span></td>
                        <td>${s.seriesCount}</td>
                        <td>${s.imageCount}</td>
                        <td class="comment-cell" onclick="event.stopPropagation()">
                            <button class="comment-toggle" data-study-uid="${escapeHtml(s.studyInstanceUid)}">
                                ${commentCount > 0 ? `${commentCount} comment${commentCount > 1 ? 's' : ''}` : 'Add comment'}
                            </button>
                        </td>
                        <td class="report-cell" onclick="event.stopPropagation()">
                            <button class="report-toggle" data-study-uid="${escapeHtml(s.studyInstanceUid)}">
                                ${reportCount > 0 ? `${reportCount} report${reportCount > 1 ? 's' : ''}` : 'Add report'}
                            </button>
                        </td>
                    </tr>
                    <tr class="comment-panel-row" data-study-uid="${escapeHtml(s.studyInstanceUid)}" style="display: none;">
                        <td colspan="9">
                            <div class="detail-panel">
                                <div class="description-section">
                                    <h4>Description</h4>
                                    <textarea class="description-input" data-study-uid="${escapeHtml(s.studyInstanceUid)}" placeholder="Add a more detailed description...">${escapeHtml(s.description || '')}</textarea>
                                </div>
                                <div class="comment-section">
                                    <h4>Comments</h4>
                                    <div class="comment-list">${renderComments(s.comments, s.studyInstanceUid)}</div>
                                    <div class="comment-add">
                                        <input type="text" class="comment-input add-study-comment" data-study-uid="${escapeHtml(s.studyInstanceUid)}" placeholder="Write a comment...">
                                        <button class="comment-submit" data-study-uid="${escapeHtml(s.studyInstanceUid)}">Add</button>
                                    </div>
                                </div>
                                <div class="report-section">
                                    <h4>Reports</h4>
                                    <div class="report-list" data-study-uid="${escapeHtml(s.studyInstanceUid)}">${renderReports(s.reports, s.studyInstanceUid)}</div>
                                    <div class="report-upload">
                                        <input type="file" class="report-file-input" data-study-uid="${escapeHtml(s.studyInstanceUid)}" accept=".pdf,.png,.jpg,.jpeg" style="display: none;">
                                        <button class="report-upload-btn" data-study-uid="${escapeHtml(s.studyInstanceUid)}">Upload Report</button>
                                    </div>
                                </div>
                            </div>
                        </td>
                    </tr>
                    <tr class="series-dropdown-row" data-study-uid="${escapeHtml(s.studyInstanceUid)}" style="display: none;">
                        <td colspan="9">
                            <div class="series-dropdown">
                                ${seriesArr.map(ser => {
                                    if (!Array.isArray(ser.comments)) ser.comments = [];
                                    const serCommentCount = ser.comments.length;
                                    const tsInfo = getTransferSyntaxInfo(ser.transferSyntax);
                                    const warningIcon = !tsInfo.supported ? `<span class="format-warning" title="${tsInfo.name} - may not display correctly">&#9888;</span>` : '';
                                    return `
                                    <div class="series-dropdown-item" data-study-uid="${escapeHtml(s.studyInstanceUid)}" data-series-uid="${escapeHtml(ser.seriesInstanceUid)}">
                                        <div class="series-main-row">
                                            <span class="series-icon">&#128196;</span>
                                            ${warningIcon}
                                            <span class="series-name">${escapeHtml(ser.seriesDescription || 'Series ' + (ser.seriesNumber || '?'))}</span>
                                            <span class="series-count">${ser.slices.length} slices</span>
                                            <button class="comment-toggle series-comment-toggle" data-study-uid="${escapeHtml(s.studyInstanceUid)}" data-series-uid="${escapeHtml(ser.seriesInstanceUid)}" onclick="event.stopPropagation()">
                                                ${serCommentCount > 0 ? `${serCommentCount} comment${serCommentCount > 1 ? 's' : ''}` : 'Add comment'}
                                            </button>
                                        </div>
                                        <div class="series-comment-panel" data-study-uid="${escapeHtml(s.studyInstanceUid)}" data-series-uid="${escapeHtml(ser.seriesInstanceUid)}" style="display: none;" onclick="event.stopPropagation()">
                                            <div class="detail-panel series-detail-panel">
                                                <div class="description-section">
                                                    <h4>Description</h4>
                                                    <textarea class="description-input series-description" data-study-uid="${escapeHtml(s.studyInstanceUid)}" data-series-uid="${escapeHtml(ser.seriesInstanceUid)}" placeholder="Add a more detailed description...">${escapeHtml(ser.description || '')}</textarea>
                                                </div>
                                                <div class="comment-section">
                                                    <h4>Comments</h4>
                                                    <div class="comment-list">${renderComments(ser.comments, s.studyInstanceUid, ser.seriesInstanceUid)}</div>
                                                    <div class="comment-add">
                                                        <input type="text" class="comment-input add-series-comment" data-study-uid="${escapeHtml(s.studyInstanceUid)}" data-series-uid="${escapeHtml(ser.seriesInstanceUid)}" placeholder="Write a comment...">
                                                        <button class="comment-submit" data-study-uid="${escapeHtml(s.studyInstanceUid)}" data-series-uid="${escapeHtml(ser.seriesInstanceUid)}">Add</button>
                                                    </div>
                                                </div>
                                            </div>
                                        </div>
                                    </div>
                                `}).join('')}
                            </div>
                        </td>
                    </tr>
                `;
            }
            studiesBody.innerHTML = html;

            // Toggle expand/collapse for series
            studiesBody.querySelectorAll('.study-row').forEach(row => {
                row.onclick = (e) => {
                    if (e.target.closest('.comment-cell') || e.target.closest('.report-cell')) return;
                    const uid = row.dataset.uid;
                    const dropdownRow = studiesBody.querySelector(`.series-dropdown-row[data-study-uid="${CSS.escape(uid)}"]`);
                    const icon = row.querySelector('.expand-icon');
                    const isExpanded = dropdownRow.style.display !== 'none';

                    // Close all series dropdowns and track state
                    studiesBody.querySelectorAll('.series-dropdown-row').forEach(r => r.style.display = 'none');
                    studiesBody.querySelectorAll('.expand-icon').forEach(i => { i.textContent = '\u25B6'; i.classList.remove('expanded'); });
                    openPanels.seriesDropdowns.clear();

                    if (!isExpanded) {
                        dropdownRow.style.display = 'table-row';
                        icon.textContent = '\u25BC';
                        icon.classList.add('expanded');
                        openPanels.seriesDropdowns.add(uid);
                    }
                };
            });

            // Toggle study comment panel
            studiesBody.querySelectorAll('.comment-toggle:not(.series-comment-toggle)').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    const studyUid = btn.dataset.studyUid;
                    const panel = studiesBody.querySelector(`.comment-panel-row[data-study-uid="${CSS.escape(studyUid)}"]`);
                    const isOpen = panel.style.display !== 'none';
                    panel.style.display = isOpen ? 'none' : 'table-row';
                    if (isOpen) {
                        openPanels.studyPanels.delete(studyUid);
                        const count = state.studies[studyUid]?.comments?.length || 0;
                        btn.textContent = count > 0 ? `${count} comment${count > 1 ? 's' : ''}` : 'Add comment';
                    } else {
                        openPanels.studyPanels.add(studyUid);
                        btn.textContent = 'Hide comments';
                    }
                };
            });

            // Toggle series comment panel
            studiesBody.querySelectorAll('.series-comment-toggle').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    const studyUid = btn.dataset.studyUid;
                    const seriesUid = btn.dataset.seriesUid;
                    const key = `${studyUid}:${seriesUid}`;
                    const panel = studiesBody.querySelector(`.series-comment-panel[data-study-uid="${CSS.escape(studyUid)}"][data-series-uid="${CSS.escape(seriesUid)}"]`);
                    const isOpen = panel.style.display !== 'none';
                    panel.style.display = isOpen ? 'none' : 'block';
                    if (isOpen) {
                        openPanels.seriesPanels.delete(key);
                        const count = state.studies[studyUid]?.series[seriesUid]?.comments?.length || 0;
                        btn.textContent = count > 0 ? `${count} comment${count > 1 ? 's' : ''}` : 'Add comment';
                    } else {
                        openPanels.seriesPanels.add(key);
                        btn.textContent = 'Hide comments';
                    }
                };
            });

            // Click on series to open viewer
            studiesBody.querySelectorAll('.series-main-row').forEach(row => {
                row.onclick = (e) => {
                    if (e.target.closest('.comment-toggle')) return;
                    const item = row.closest('.series-dropdown-item');
                    const studyUid = item.dataset.studyUid;
                    const seriesUid = item.dataset.seriesUid;
                    openViewerWithSeries(studyUid, seriesUid);
                };
            });

            // Add study comment
            studiesBody.querySelectorAll('.comment-submit:not([data-series-uid])').forEach(btn => {
                btn.onclick = () => {
                    const studyUid = btn.dataset.studyUid;
                    const input = studiesBody.querySelector(`.add-study-comment[data-study-uid="${CSS.escape(studyUid)}"]`);
                    addComment(studyUid, null, input.value);
                };
            });

            // Add series comment
            studiesBody.querySelectorAll('.comment-submit[data-series-uid]').forEach(btn => {
                btn.onclick = () => {
                    const studyUid = btn.dataset.studyUid;
                    const seriesUid = btn.dataset.seriesUid;
                    const input = studiesBody.querySelector(`.add-series-comment[data-study-uid="${CSS.escape(studyUid)}"][data-series-uid="${CSS.escape(seriesUid)}"]`);
                    addComment(studyUid, seriesUid, input.value);
                };
            });

            // Enter key to submit
            studiesBody.querySelectorAll('.comment-input').forEach(input => {
                input.onkeydown = (e) => {
                    if (e.key === 'Enter') {
                        const studyUid = input.dataset.studyUid;
                        const seriesUid = input.dataset.seriesUid || null;
                        addComment(studyUid, seriesUid, input.value);
                    }
                };
            });

            // Edit/Delete buttons
            studiesBody.querySelectorAll('.edit-comment').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    editComment(btn.dataset.studyUid, btn.dataset.seriesUid || null, btn.dataset.commentId);
                };
            });
            studiesBody.querySelectorAll('.delete-comment').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    deleteComment(btn.dataset.studyUid, btn.dataset.seriesUid || null, btn.dataset.commentId);
                };
            });

            // Save study description on input
            studiesBody.querySelectorAll('.description-input:not(.series-description)').forEach(textarea => {
                textarea.oninput = () => {
                    const studyUid = textarea.dataset.studyUid;
                    if (state.studies[studyUid]) {
                        state.studies[studyUid].description = textarea.value;
                        scheduleDescriptionSave(`study:${studyUid}`, () => {
                            NotesAPI.saveStudyDescription(studyUid, textarea.value);
                        });
                    }
                };
            });

            // Save series description on input
            studiesBody.querySelectorAll('.series-description').forEach(textarea => {
                textarea.oninput = () => {
                    const studyUid = textarea.dataset.studyUid;
                    const seriesUid = textarea.dataset.seriesUid;
                    if (state.studies[studyUid]?.series[seriesUid]) {
                        state.studies[studyUid].series[seriesUid].description = textarea.value;
                        scheduleDescriptionSave(`series:${studyUid}:${seriesUid}`, () => {
                            NotesAPI.saveSeriesDescription(studyUid, seriesUid, textarea.value);
                        });
                    }
                };
            });

            // Restore open panels
            openPanels.studyPanels.forEach(studyUid => {
                const panel = studiesBody.querySelector(`.comment-panel-row[data-study-uid="${CSS.escape(studyUid)}"]`);
                if (panel) panel.style.display = 'table-row';
                const btn = studiesBody.querySelector(`.comment-toggle[data-study-uid="${CSS.escape(studyUid)}"]:not(.series-comment-toggle)`);
                if (btn) btn.textContent = 'Hide comments';
            });
            openPanels.seriesPanels.forEach(key => {
                const [studyUid, seriesUid] = key.split(':');
                const panel = studiesBody.querySelector(`.series-comment-panel[data-study-uid="${CSS.escape(studyUid)}"][data-series-uid="${CSS.escape(seriesUid)}"]`);
                if (panel) panel.style.display = 'block';
                const btn = studiesBody.querySelector(`.series-comment-toggle[data-study-uid="${CSS.escape(studyUid)}"][data-series-uid="${CSS.escape(seriesUid)}"]`);
                if (btn) btn.textContent = 'Hide comments';
                // Also need to open the series dropdown
                const dropdown = studiesBody.querySelector(`.series-dropdown-row[data-study-uid="${CSS.escape(studyUid)}"]`);
                if (dropdown) dropdown.style.display = 'table-row';
                const icon = studiesBody.querySelector(`.study-row[data-uid="${CSS.escape(studyUid)}"] .expand-icon`);
                if (icon) { icon.textContent = '\u25BC'; icon.classList.add('expanded'); }
            });
            openPanels.seriesDropdowns.forEach(studyUid => {
                const dropdown = studiesBody.querySelector(`.series-dropdown-row[data-study-uid="${CSS.escape(studyUid)}"]`);
                if (dropdown) dropdown.style.display = 'table-row';
                const icon = studiesBody.querySelector(`.study-row[data-uid="${CSS.escape(studyUid)}"] .expand-icon`);
                if (icon) { icon.textContent = '\u25BC'; icon.classList.add('expanded'); }
            });

            // Report toggle button (reuses comment panel, same behavior)
            studiesBody.querySelectorAll('.report-toggle').forEach(btn => {
                btn.onclick = (e) => {
                    e.stopPropagation();
                    const studyUid = btn.dataset.studyUid;
                    const panel = studiesBody.querySelector(`.comment-panel-row[data-study-uid="${CSS.escape(studyUid)}"]`);
                    const isOpen = panel.style.display !== 'none';
                    panel.style.display = isOpen ? 'none' : 'table-row';
                    if (isOpen) {
                        openPanels.studyPanels.delete(studyUid);
                    } else {
                        openPanels.studyPanels.add(studyUid);
                    }
                };
            });

            // Report upload button -> trigger file input
            studiesBody.querySelectorAll('.report-upload-btn').forEach(btn => {
                const studyUid = btn.dataset.studyUid;
                const fileInput = studiesBody.querySelector(`.report-file-input[data-study-uid="${CSS.escape(studyUid)}"]`);
                btn.onclick = (e) => {
                    e.stopPropagation();
                    fileInput.click();
                };
                fileInput.onchange = async () => {
                    const file = fileInput.files[0];
                    if (file) {
                        await addReport(studyUid, file);
                        fileInput.value = '';
                    }
                };
            });

            // Attach report event handlers for all studies
            Object.keys(state.studies).forEach(studyUid => {
                attachReportEventHandlers(studyUid);
            });
        }

        // =====================================================================
        // TRANSFER SYNTAX SUPPORT
        // DICOM images can be stored in various compression formats.
        // The Transfer Syntax UID (0002,0010) identifies the format.
        // =====================================================================

        /**
         * Check if a transfer syntax indicates compressed pixel data
         * @param {string} transferSyntax - Transfer Syntax UID
         * @returns {boolean} True if compressed
         */
        function isCompressed(transferSyntax) {
            if (!transferSyntax) return false;
            // JPEG Lossless, JPEG 2000, JPEG Baseline, RLE, etc.
            return transferSyntax.startsWith('1.2.840.10008.1.2.4') ||
                   transferSyntax === '1.2.840.10008.1.2.5'; // RLE
        }

        function isJpegLossless(transferSyntax) {
            // JPEG Lossless transfer syntaxes
            return transferSyntax === '1.2.840.10008.1.2.4.57' || // JPEG Lossless
                   transferSyntax === '1.2.840.10008.1.2.4.70';   // JPEG Lossless First-Order
        }

        function isJpegBaseline(transferSyntax) {
            return transferSyntax === '1.2.840.10008.1.2.4.50' || // JPEG Baseline
                   transferSyntax === '1.2.840.10008.1.2.4.51';   // JPEG Extended
        }

        function isJpeg2000(transferSyntax) {
            return transferSyntax === '1.2.840.10008.1.2.4.90' || // JPEG 2000 Lossless
                   transferSyntax === '1.2.840.10008.1.2.4.91';   // JPEG 2000 Lossy
        }

        // Transfer syntax names and support status
        const TRANSFER_SYNTAX_INFO = {
            // Uncompressed - Supported
            '1.2.840.10008.1.2': { name: 'Implicit VR Little Endian', supported: true },
            '1.2.840.10008.1.2.1': { name: 'Explicit VR Little Endian', supported: true },
            '1.2.840.10008.1.2.2': { name: 'Explicit VR Big Endian', supported: true },
            // JPEG Lossless - Supported
            '1.2.840.10008.1.2.4.57': { name: 'JPEG Lossless', supported: true },
            '1.2.840.10008.1.2.4.70': { name: 'JPEG Lossless (First-Order Prediction)', supported: true },
            // JPEG Baseline - Supported
            '1.2.840.10008.1.2.4.50': { name: 'JPEG Baseline (8-bit)', supported: true },
            '1.2.840.10008.1.2.4.51': { name: 'JPEG Extended (12-bit)', supported: true },
            // JPEG 2000 - Supported
            '1.2.840.10008.1.2.4.90': { name: 'JPEG 2000 Lossless', supported: true },
            '1.2.840.10008.1.2.4.91': { name: 'JPEG 2000 Lossy', supported: true },
            // RLE - Not supported
            '1.2.840.10008.1.2.5': { name: 'RLE Lossless', supported: false },
            // JPEG-LS - Not supported
            '1.2.840.10008.1.2.4.80': { name: 'JPEG-LS Lossless', supported: false },
            '1.2.840.10008.1.2.4.81': { name: 'JPEG-LS Near-Lossless', supported: false },
            // MPEG - Not supported
            '1.2.840.10008.1.2.4.100': { name: 'MPEG-2', supported: false },
            '1.2.840.10008.1.2.4.101': { name: 'MPEG-2 HD', supported: false },
            '1.2.840.10008.1.2.4.102': { name: 'MPEG-4', supported: false },
            '1.2.840.10008.1.2.4.103': { name: 'MPEG-4 BD', supported: false },
            // Deflated - Not supported
            '1.2.840.10008.1.2.1.99': { name: 'Deflated Explicit VR Little Endian', supported: false },
            // HEVC - Not supported
            '1.2.840.10008.1.2.4.107': { name: 'HEVC/H.265', supported: false },
        };

        function getTransferSyntaxInfo(transferSyntax) {
            if (!transferSyntax) {
                return { name: 'Unknown', supported: false, unknown: true };
            }
            const info = TRANSFER_SYNTAX_INFO[transferSyntax];
            if (info) {
                return { ...info, uid: transferSyntax, unknown: false };
            }
            return { name: `Unknown (${transferSyntax})`, supported: false, unknown: true, uid: transferSyntax };
        }

        // =====================================================================
        // MODALITY-SPECIFIC DEFAULTS
        // Different imaging modalities require different window/level settings
        // =====================================================================

        /**
         * Default window/level values by modality
         * CT uses Hounsfield Units (-1000 air, 0 water, +1000 bone)
         * MR uses arbitrary signal intensity (depends on sequence)
         * Other modalities have their own ranges
         */
        const MODALITY_DEFAULTS = {
            'CT': { windowCenter: 40, windowWidth: 400 },      // Soft tissue window
            'MR': { windowCenter: 512, windowWidth: 1024 },    // Mid-range for typical MRI
            'PT': { windowCenter: 256, windowWidth: 512 },     // PET
            'NM': { windowCenter: 256, windowWidth: 512 },     // Nuclear Medicine
            'US': { windowCenter: 128, windowWidth: 256 },     // Ultrasound (8-bit typical)
            'CR': { windowCenter: 2048, windowWidth: 4096 },   // Computed Radiography
            'DX': { windowCenter: 2048, windowWidth: 4096 },   // Digital X-Ray
            'MG': { windowCenter: 2048, windowWidth: 4096 },   // Mammography
            'XA': { windowCenter: 128, windowWidth: 256 },     // X-Ray Angiography
            'RF': { windowCenter: 128, windowWidth: 256 },     // Radiofluoroscopy
        };

        /**
         * Get default window/level for a modality
         * @param {string} modality - DICOM modality code (CT, MR, etc.)
         * @returns {Object} {windowCenter, windowWidth}
         */
        function getModalityDefaults(modality) {
            return MODALITY_DEFAULTS[modality] || { windowCenter: 128, windowWidth: 256 };
        }

        /**
         * Calculate auto window/level from pixel data statistics
         * Useful for MRI and other modalities without standard units
         * @param {TypedArray} pixelData - Raw pixel values
         * @param {number} rescaleSlope - Rescale slope
         * @param {number} rescaleIntercept - Rescale intercept
         * @returns {Object} {windowCenter, windowWidth, isBlank}
         */
        function calculateAutoWindowLevel(pixelData, rescaleSlope = 1, rescaleIntercept = 0) {
            // Sample pixels for speed (every 10th pixel)
            let min = Infinity, max = -Infinity;
            let sum = 0, count = 0;

            for (let i = 0; i < pixelData.length; i += 10) {
                const value = pixelData[i] * rescaleSlope + rescaleIntercept;
                if (value < min) min = value;
                if (value > max) max = value;
                sum += value;
                count++;
            }

            const mean = sum / count;
            const range = max - min;

            // Detect blank/uniform slices (all pixels have same or nearly same value)
            // This commonly occurs in MPR reconstructions as padding slices
            const isBlank = range < 1;

            // Use percentile-based windowing to handle outliers
            // Center at mean, width covers most of the dynamic range
            const windowWidth = Math.max(range * 0.9, 1);  // 90% of range
            const windowCenter = mean;

            return { windowCenter: Math.round(windowCenter), windowWidth: Math.round(windowWidth), isBlank };
        }

        /**
         * Check if pixel data represents a blank/uniform slice
         * @param {TypedArray} pixelData - Raw pixel values
         * @param {number} rescaleSlope - Rescale slope
         * @param {number} rescaleIntercept - Rescale intercept
         * @returns {boolean} True if slice is blank (all pixels same value)
         */
        function isBlankSlice(pixelData, rescaleSlope = 1, rescaleIntercept = 0) {
            // Sample pixels for speed (every 10th pixel)
            let min = Infinity, max = -Infinity;

            for (let i = 0; i < pixelData.length; i += 10) {
                const value = pixelData[i] * rescaleSlope + rescaleIntercept;
                if (value < min) min = value;
                if (value > max) max = value;
                // Early exit if we find variation
                if (max - min >= 1) return false;
            }

            return (max - min) < 1;
        }

        /**
         * Display a blank slice as black (like Horos)
         * @param {number} rows - Image height
         * @param {number} cols - Image width
         */
        function displayBlankSlice(rows, cols) {
            canvas.width = cols;
            canvas.height = rows;
            ctx.fillStyle = '#000';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
        }

        // =====================================================================
        // IMAGE DECODING
        // Different compression formats require different decoders
        // =====================================================================

        /**
         * Decode JPEG Lossless compressed pixel data
         * Uses the jpeg-lossless-decoder-js library
         *
         * @param {Object} dataSet - dicomParser dataset
         * @param {Object} pixelDataElement - Pixel data element (x7fe00010)
         * @param {number} rows - Image height
         * @param {number} cols - Image width
         * @param {number} bitsAllocated - Bits per pixel (8 or 16)
         * @returns {TypedArray|null} Decoded pixel data or null on failure
         */
        function decodeJpegLossless(dataSet, pixelDataElement, rows, cols, bitsAllocated) {
            try {
                let frameData;

                // Try using dicomParser's built-in function first
                if (pixelDataElement.fragments && pixelDataElement.fragments.length > 0) {
                    frameData = dicomParser.readEncapsulatedPixelDataFromFragments(
                        dataSet, pixelDataElement, 0
                    );
                } else {
                    // Manually parse encapsulated pixel data
                    const byteArray = dataSet.byteArray;
                    let offset = pixelDataElement.dataOffset;

                    // Skip the basic offset table item
                    const itemTag1 = byteArray[offset] | (byteArray[offset+1] << 8);
                    const itemTag2 = byteArray[offset+2] | (byteArray[offset+3] << 8);

                    if (itemTag1 === 0xFFFE && itemTag2 === 0xE000) {
                        const botLength = byteArray[offset+4] | (byteArray[offset+5] << 8) |
                                         (byteArray[offset+6] << 16) | (byteArray[offset+7] << 24);
                        offset += 8 + botLength;

                        const fragTag1 = byteArray[offset] | (byteArray[offset+1] << 8);
                        const fragTag2 = byteArray[offset+2] | (byteArray[offset+3] << 8);

                        if (fragTag1 === 0xFFFE && fragTag2 === 0xE000) {
                            const fragLength = byteArray[offset+4] | (byteArray[offset+5] << 8) |
                                              (byteArray[offset+6] << 16) | (byteArray[offset+7] << 24);
                            offset += 8;
                            frameData = new Uint8Array(byteArray.buffer, byteArray.byteOffset + offset, fragLength);
                        }
                    }
                }

                if (!frameData) {
                    console.error('Could not extract frame data');
                    return null;
                }

                const decoder = new jpeg.lossless.Decoder();
                const decodedData = decoder.decode(frameData.buffer, frameData.byteOffset, frameData.length);

                // Handle the decoded output based on bits allocated
                if (bitsAllocated === 16) {
                    return new Int16Array(decodedData.buffer);
                } else {
                    return new Uint8Array(decodedData.buffer);
                }
            } catch (e) {
                console.error('JPEG Lossless decode error:', e);
                return null;
            }
        }

        // ---------------------------------------------------------------------
        // JPEG 2000 Decoding (OpenJPEG WebAssembly)
        // ---------------------------------------------------------------------

        /** Cached OpenJPEG WASM module instance */
        let openjpegModule = null;
        /** Promise for OpenJPEG initialization (prevents multiple init) */
        let openjpegInitPromise = null;

        /**
         * Initialize the OpenJPEG WebAssembly decoder
         * Lazily loaded on first JPEG 2000 image
         * @returns {Promise<Object>} Initialized OpenJPEG module
         */
        async function initOpenJPEG() {
            if (openjpegModule) return openjpegModule;
            if (openjpegInitPromise) return openjpegInitPromise;

            openjpegInitPromise = (async () => {
                try {
                    console.log('Initializing OpenJPEG WASM...');
                    // OpenJPEGWASM is loaded from the script tag
                    if (typeof OpenJPEGWASM === 'function') {
                        openjpegModule = await OpenJPEGWASM({
                            locateFile: (path) => 'js/' + path
                        });
                        console.log('OpenJPEG WASM initialized successfully');
                        return openjpegModule;
                    }
                    throw new Error('OpenJPEGWASM not found');
                } catch (e) {
                    console.error('Failed to initialize OpenJPEG:', e);
                    throw e;
                }
            })();

            return openjpegInitPromise;
        }

        /**
         * Decode JPEG 2000 compressed pixel data using OpenJPEG WASM
         *
         * @param {Object} dataSet - dicomParser dataset
         * @param {Object} pixelDataElement - Pixel data element (unused, uses dataSet.elements)
         * @param {number} rows - Image height
         * @param {number} cols - Image width
         * @param {number} bitsAllocated - Bits per pixel
         * @param {number} pixelRepresentation - 0=unsigned, 1=signed
         * @returns {Promise<TypedArray|null>} Decoded pixel data or null on failure
         */
        async function decodeJpeg2000(dataSet, pixelDataElement, rows, cols, bitsAllocated, pixelRepresentation) {
            try {
                console.log('Attempting JPEG 2000 decode for', rows, 'x', cols, 'image');

                const jp2DataElement = dataSet.elements.x7fe00010;
                if (!jp2DataElement.encapsulatedPixelData) {
                    console.error('Pixel data is not encapsulated');
                    return null;
                }

                const fragments = jp2DataElement.fragments;
                if (!fragments || fragments.length === 0) {
                    console.error('No fragments found for JPEG 2000');
                    return null;
                }

                // Get the first fragment (single frame)
                const fragment = fragments[0];
                const j2kData = new Uint8Array(dataSet.byteArray.buffer, fragment.position, fragment.length);
                console.log('JPEG 2000 data length:', j2kData.length, 'bytes');

                // Initialize and use OpenJPEG decoder
                const oj = await initOpenJPEG();

                // Use the J2KDecoder class from the WASM module
                const decoder = new oj.J2KDecoder();
                const encodedBuffer = decoder.getEncodedBuffer(j2kData.length);
                encodedBuffer.set(j2kData);

                decoder.decode();

                const decoded = decoder.getDecodedBuffer();
                const frameInfo = decoder.getFrameInfo();

                console.log('JPEG 2000 decoded:', frameInfo.width, 'x', frameInfo.height,
                            'components:', frameInfo.componentCount, 'bpp:', frameInfo.bitsPerSample);

                // Copy decoded data to a new array before cleanup
                let pixelData;
                if (frameInfo.bitsPerSample > 8) {
                    if (frameInfo.isSigned) {
                        pixelData = new Int16Array(decoded.length / 2);
                        const view = new DataView(decoded.buffer, decoded.byteOffset, decoded.byteLength);
                        for (let i = 0; i < pixelData.length; i++) {
                            pixelData[i] = view.getInt16(i * 2, true);
                        }
                    } else {
                        pixelData = new Uint16Array(decoded.length / 2);
                        const view = new DataView(decoded.buffer, decoded.byteOffset, decoded.byteLength);
                        for (let i = 0; i < pixelData.length; i++) {
                            pixelData[i] = view.getUint16(i * 2, true);
                        }
                    }
                } else {
                    pixelData = new Uint8Array(decoded);
                }

                decoder.delete();
                return pixelData;

            } catch (e) {
                console.error('JPEG 2000 decode error:', e);
                return null;
            }
        }

        /**
         * Decode JPEG Baseline compressed pixel data using browser's native decoder
         * Creates a Blob from the JPEG data and uses createImageBitmap to decode
         *
         * @param {Object} dataSet - dicomParser dataset
         * @param {Object} pixelDataElement - Pixel data element (unused)
         * @param {number} rows - Image height
         * @param {number} cols - Image width
         * @returns {Promise<Object|null>} {pixels, isRgb} or null on failure
         */
        async function decodeJpegBaseline(dataSet, pixelDataElement, rows, cols) {
            try {
                const frames = dicomParser.readEncapsulatedPixelDataFromFragments(
                    dataSet, dataSet.elements.x7fe00010, 0
                );

                const blob = new Blob([frames], { type: 'image/jpeg' });
                const bitmap = await createImageBitmap(blob);

                const tempCanvas = document.createElement('canvas');
                tempCanvas.width = cols;
                tempCanvas.height = rows;
                const tempCtx = tempCanvas.getContext('2d');
                tempCtx.drawImage(bitmap, 0, 0);

                const imageData = tempCtx.getImageData(0, 0, cols, rows);
                // Convert RGBA to grayscale values
                const pixels = new Int16Array(rows * cols);
                for (let i = 0; i < pixels.length; i++) {
                    pixels[i] = imageData.data[i * 4]; // Just use red channel
                }
                return { pixels, isRgb: true };
            } catch (e) {
                console.error('JPEG Baseline decode error:', e);
                return null;
            }
        }

        // =====================================================================
        // RENDERING
        // Converts decoded pixel data to visible image on canvas
        // =====================================================================

        /**
         * Display an error message on the canvas when image cannot be decoded
         * @param {string} message - Main error message
         * @param {string} details - Additional details (e.g., format name)
         */
        function displayError(message, details) {
            canvas.width = 512;
            canvas.height = 512;
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.fillStyle = '#f0ad4e';
            ctx.font = 'bold 18px -apple-system, sans-serif';
            ctx.textAlign = 'center';
            ctx.fillText(' Unable to Display Image', canvas.width / 2, 200);

            ctx.fillStyle = '#ccc';
            ctx.font = '14px -apple-system, sans-serif';
            ctx.fillText(message, canvas.width / 2, 240);

            if (details) {
                ctx.fillStyle = '#888';
                ctx.font = '12px -apple-system, sans-serif';
                ctx.fillText(details, canvas.width / 2, 270);
            }

            ctx.fillStyle = '#666';
            ctx.font = '12px -apple-system, sans-serif';
            ctx.fillText('This format may require additional decoders', canvas.width / 2, 310);
        }

        /**
         * Render a DICOM dataset to the canvas
         * Handles decompression, window/level adjustment, and display
         *
         * @param {Object} dataSet - Parsed dicomParser dataset with pixel data
         * @param {Object|null} wlOverride - Optional {center, width} to override DICOM values
         * @returns {Promise<Object>} Rendering info {rows, cols, wc, ww, transferSyntax} or {error: true}
         */
        async function renderDicom(dataSet, wlOverride = null) {
            // Extract image dimensions and pixel format from DICOM tags
            const rows = dataSet.uint16('x00280010');              // (0028,0010) Rows
            const cols = dataSet.uint16('x00280011');              // (0028,0011) Columns
            const bitsAllocated = dataSet.uint16('x00280100') || 16;  // (0028,0100) Bits Allocated
            const pixelRepresentation = dataSet.uint16('x00280103') || 0;  // (0028,0103) 0=unsigned, 1=signed

            // Get modality for appropriate defaults
            const modality = getString(dataSet, 'x00080060');  // (0008,0060) Modality

            // Rescale slope/intercept for converting stored values
            // CT: converts to Hounsfield Units; MR: arbitrary signal intensity
            const rescaleSlope = getNumber(dataSet, 'x00281053', 1);     // (0028,1053)
            const rescaleIntercept = getNumber(dataSet, 'x00281052', 0); // (0028,1052)

            // Window/level for display - use modality-appropriate defaults
            const modalityDefaults = getModalityDefaults(modality);
            let windowCenter = getNumber(dataSet, 'x00281050', 0);  // (0028,1050)
            let windowWidth = getNumber(dataSet, 'x00281051', 0);   // (0028,1051)

            // If window/level not in DICOM, use modality defaults
            // (we'll potentially override with auto-calculation for MRI later)
            const hasWindowLevel = windowCenter !== 0 || windowWidth !== 0;
            if (!hasWindowLevel) {
                windowCenter = modalityDefaults.windowCenter;
                windowWidth = modalityDefaults.windowWidth;
            }

            // Extract pixel spacing for measurement calibration
            const pixelSpacing = extractPixelSpacing(dataSet);
            state.pixelSpacing = pixelSpacing;
            updateCalibrationWarning();

            // Extract MRI-specific metadata
            const mrMetadata = {
                repetitionTime: getNumber(dataSet, 'x00180080', 0),     // (0018,0080) TR
                echoTime: getNumber(dataSet, 'x00180081', 0),          // (0018,0081) TE
                flipAngle: getNumber(dataSet, 'x00181314', 0),         // (0018,1314) Flip Angle
                magneticFieldStrength: getNumber(dataSet, 'x00180087', 0), // (0018,0087) Field Strength
                protocolName: getString(dataSet, 'x00181030'),         // (0018,1030) Protocol Name
                sequenceName: getString(dataSet, 'x00180024'),         // (0018,0024) Sequence Name
                scanningSequence: getString(dataSet, 'x00180020'),     // (0018,0020) Scanning Sequence
                mrAcquisitionType: getString(dataSet, 'x00180023'),    // (0018,0023) MR Acquisition Type (2D/3D)
            };

            // Get transfer syntax to determine compression format
            const transferSyntax = getString(dataSet, 'x00020010');  // (0002,0010)
            console.log('Transfer Syntax:', transferSyntax, 'Compressed:', isCompressed(transferSyntax));

            // Get pixel data element
            const pixelDataElement = dataSet.elements.x7fe00010;  // (7FE0,0010) Pixel Data
            const transferSyntaxInfo = getTransferSyntaxInfo(transferSyntax);

            if (!pixelDataElement) {
                console.error('No pixel data element found');
                displayError('No pixel data found', 'The DICOM file may be corrupted or incomplete');
                return { error: true };
            }

            let pixelData;
            let skipWindowLevel = false;

            // Determine if pixel data is compressed based on transfer syntax
            const isCompressedData = isCompressed(transferSyntax);

            if (isCompressedData) {
                // Decode compressed pixel data using appropriate decoder
                if (isJpeg2000(transferSyntax)) {
                    pixelData = await decodeJpeg2000(dataSet, pixelDataElement, rows, cols, bitsAllocated, pixelRepresentation);
                    if (!pixelData) {
                        displayError('JPEG 2000 decode failed', transferSyntaxInfo.name);
                        return { error: true, transferSyntax, tsInfo: transferSyntaxInfo };
                    }
                } else if (isJpegLossless(transferSyntax)) {
                    pixelData = decodeJpegLossless(dataSet, pixelDataElement, rows, cols, bitsAllocated);
                    if (!pixelData) {
                        displayError('JPEG Lossless decode failed', transferSyntaxInfo.name);
                        return { error: true, transferSyntax, tsInfo: transferSyntaxInfo };
                    }
                } else if (isJpegBaseline(transferSyntax)) {
                    const result = await decodeJpegBaseline(dataSet, pixelDataElement, rows, cols);
                    if (!result) {
                        displayError('JPEG decode failed', transferSyntaxInfo.name);
                        return { error: true, transferSyntax, tsInfo: transferSyntaxInfo };
                    }
                    pixelData = result.pixels;
                    skipWindowLevel = result.isRgb; // Already 0-255 from JPEG decode
                } else {
                    // Unsupported compression format
                    displayError('Unsupported compression format', transferSyntaxInfo.name);
                    return { error: true, transferSyntax, tsInfo: transferSyntaxInfo };
                }
            } else {
                // Uncompressed pixel data - create typed array view directly on buffer
                if (bitsAllocated === 16) {
                    pixelData = pixelRepresentation === 1
                        ? new Int16Array(dataSet.byteArray.buffer, pixelDataElement.dataOffset, pixelDataElement.length / 2)
                        : new Uint16Array(dataSet.byteArray.buffer, pixelDataElement.dataOffset, pixelDataElement.length / 2);
                } else {
                    pixelData = new Uint8Array(dataSet.byteArray.buffer, pixelDataElement.dataOffset, pixelDataElement.length);
                }
            }

            // Check for blank/uniform slices (common in MPR reconstructions as padding)
            // This must be done before window/level calculations
            if (isBlankSlice(pixelData, rescaleSlope, rescaleIntercept)) {
                console.log('Detected blank slice (all pixels same value)');
                displayBlankSlice(rows, cols);
                return {
                    rows, cols,
                    wc: windowCenter, ww: windowWidth,
                    transferSyntax, modality,
                    mrMetadata,
                    isBlank: true
                };
            }

            // For MRI without window/level in DICOM, calculate auto window/level
            // based on actual pixel data statistics
            if (!hasWindowLevel && (modality === 'MR' || modality === 'PT' || modality === 'NM')) {
                const autoWL = calculateAutoWindowLevel(pixelData, rescaleSlope, rescaleIntercept);
                windowCenter = autoWL.windowCenter;
                windowWidth = autoWL.windowWidth;
                console.log(`Auto window/level for ${modality}: C=${windowCenter} W=${windowWidth}`);
            }

            // Store base W/L values for reset (only on first render, not re-renders)
            if (state.baseWindowLevel.center === null) {
                state.baseWindowLevel = { center: windowCenter, width: windowWidth };
            }

            // Apply W/L override if provided (from user drag adjustment)
            if (wlOverride && wlOverride.center !== null && wlOverride.width !== null) {
                windowCenter = wlOverride.center;
                windowWidth = wlOverride.width;
            }

            // Set canvas size to match image dimensions
            canvas.width = cols;
            canvas.height = rows;

            // Create image data buffer for canvas
            const imageData = ctx.createImageData(cols, rows);
            const outputPixels = imageData.data;

            // Calculate window/level range (min/max displayable values)
            const windowMin = windowCenter - windowWidth / 2;
            const windowMax = windowCenter + windowWidth / 2;

            // Apply rescale and window/level transform to each pixel
            for (let i = 0; i < pixelData.length; i++) {
                let grayscaleValue;
                if (skipWindowLevel) {
                    // Already 0-255 (e.g., from JPEG baseline decode)
                    grayscaleValue = pixelData[i];
                } else {
                    // Apply rescale slope/intercept
                    // CT: converts to Hounsfield Units; MR: arbitrary signal intensity
                    let pixelValue = pixelData[i] * rescaleSlope + rescaleIntercept;
                    // Clamp to window range and scale to 0-255
                    pixelValue = Math.max(windowMin, Math.min(windowMax, pixelValue));
                    grayscaleValue = Math.round(((pixelValue - windowMin) / (windowMax - windowMin)) * 255);
                }
                // Set RGBA values (grayscale = R=G=B, alpha=255)
                const pixelIndex = i * 4;
                outputPixels[pixelIndex] = grayscaleValue;      // R
                outputPixels[pixelIndex + 1] = grayscaleValue;  // G
                outputPixels[pixelIndex + 2] = grayscaleValue;  // B
                outputPixels[pixelIndex + 3] = 255;             // A (opaque)
            }

            // Draw to canvas
            ctx.putImageData(imageData, 0, 0);

            return {
                rows, cols,
                wc: windowCenter, ww: windowWidth,
                transferSyntax, modality,
                mrMetadata
            };
        }

        // =====================================================================
        // VIEWER CONTROLS
        // Slice navigation and series selection
        // =====================================================================

        /**
         * Load and display a specific slice from the current series
         * Handles caching and preloading of adjacent slices
         *
         * @param {number} index - Zero-based slice index
         */
        async function loadSlice(index) {
            if (!state.currentSeries) return;
            const slices = state.currentSeries.slices;
            if (index < 0 || index >= slices.length) return;

            state.currentSliceIndex = index;
            updateSliceInfo();
            imageLoading.style.display = 'block';

            try {
                const slice = slices[index];
                let dataSet = state.sliceCache.get(index);

                if (!dataSet) {
                    // Handle both file handles (drag-drop) and blobs (sample loading)
                    let buf;
                    if (slice.fileHandle) {
                        const file = await slice.fileHandle.getFile();
                        buf = await file.arrayBuffer();
                    } else if (slice.blob) {
                        buf = await slice.blob.arrayBuffer();
                    }
                    dataSet = dicomParser.parseDicom(new Uint8Array(buf));
                    state.sliceCache.set(index, dataSet);
                }

                // Pass W/L override if user has adjusted values
                const wlOverride = (state.windowLevel.center !== null && state.windowLevel.width !== null)
                    ? state.windowLevel : null;
                const info = await renderDicom(dataSet, wlOverride);

                // Update W/L display in toolbar
                updateWLDisplay();

                if (info && !info.error) {
                    // Build base metadata (common to all modalities)
                    let metadataHtml = `
                        <div class="metadata-item"><div class="label">Slice</div><div class="value">${index + 1} / ${slices.length}</div></div>
                        <div class="metadata-item"><div class="label">Modality</div><div class="value">${escapeHtml(info.modality || '-')}</div></div>
                        <div class="metadata-item"><div class="label">Size</div><div class="value">${info.cols} x ${info.rows}</div></div>
                        <div class="metadata-item"><div class="label">Location</div><div class="value">${slice.sliceLocation?.toFixed(2) || '-'} mm</div></div>
                        <div class="metadata-item"><div class="label">Window</div><div class="value">C:${info.wc} W:${info.ww}</div></div>
                    `;

                    // Add MRI-specific metadata
                    if (info.modality === 'MR' && info.mrMetadata) {
                        const mr = info.mrMetadata;
                        metadataHtml += `<div class="metadata-divider"></div>`;

                        if (mr.protocolName) {
                            metadataHtml += `<div class="metadata-item"><div class="label">Protocol</div><div class="value">${escapeHtml(mr.protocolName)}</div></div>`;
                        }
                        if (mr.sequenceName) {
                            metadataHtml += `<div class="metadata-item"><div class="label">Sequence</div><div class="value">${escapeHtml(mr.sequenceName)}</div></div>`;
                        }
                        if (mr.repetitionTime) {
                            metadataHtml += `<div class="metadata-item"><div class="label">TR</div><div class="value">${mr.repetitionTime.toFixed(1)} ms</div></div>`;
                        }
                        if (mr.echoTime) {
                            metadataHtml += `<div class="metadata-item"><div class="label">TE</div><div class="value">${mr.echoTime.toFixed(1)} ms</div></div>`;
                        }
                        if (mr.flipAngle) {
                            metadataHtml += `<div class="metadata-item"><div class="label">Flip Angle</div><div class="value">${escapeHtml(mr.flipAngle)}</div></div>`;
                        }
                        if (mr.magneticFieldStrength) {
                            metadataHtml += `<div class="metadata-item"><div class="label">Field</div><div class="value">${escapeHtml(mr.magneticFieldStrength)}T</div></div>`;
                        }
                    }

                    metadataContent.innerHTML = metadataHtml;
                } else if (info && info.isBlank) {
                    // Blank/padding slice - show basic info
                    metadataContent.innerHTML = `
                        <div class="metadata-item"><div class="label">Slice</div><div class="value">${index + 1} / ${slices.length}</div></div>
                        <div class="metadata-item"><div class="label">Modality</div><div class="value">${escapeHtml(info.modality || '-')}</div></div>
                        <div class="metadata-item"><div class="label">Size</div><div class="value">${info.cols} x ${info.rows}</div></div>
                        <div class="metadata-item"><div class="label">Location</div><div class="value">${slice.sliceLocation?.toFixed(2) || '-'} mm</div></div>
                    `;
                } else if (info && info.error) {
                    metadataContent.innerHTML = `
                        <div class="metadata-item"><div class="label">Slice</div><div class="value">${index + 1} / ${slices.length}</div></div>
                        <div class="metadata-item"><div class="label">Status</div><div class="value" style="color: #f0ad4e;">Decode Error</div></div>
                        <div class="metadata-item"><div class="label">Format</div><div class="value">${info.tsInfo?.name || 'Unknown'}</div></div>
                    `;
                }

                // Preload adjacent slices
                for (let i = index - 3; i <= index + 3; i++) {
                    if (i >= 0 && i < slices.length && !state.sliceCache.has(i)) {
                        const s = slices[i];
                        // Handle both file handles and blobs
                        const getBuffer = s.fileHandle
                            ? s.fileHandle.getFile().then(f => f.arrayBuffer())
                            : s.blob ? s.blob.arrayBuffer() : Promise.reject();
                        getBuffer.then(buf => {
                            state.sliceCache.set(i, dicomParser.parseDicom(new Uint8Array(buf)));
                        }).catch(() => {});
                    }
                }
            } catch (e) {
                console.error('Error loading slice:', e);
            }
            imageLoading.style.display = 'none';
            // Redraw measurements for the new slice
            drawMeasurements();
        }

        function updateSliceInfo() {
            const total = state.currentSeries?.slices.length || 0;
            sliceInfo.textContent = `${state.currentSliceIndex + 1} / ${total}`;
            slider.value = state.currentSliceIndex;
            prevBtn.disabled = state.currentSliceIndex <= 0;
            nextBtn.disabled = state.currentSliceIndex >= total - 1;
        }

        function selectSeries(seriesUid) {
            state.currentSeries = state.currentStudy.series[seriesUid];
            state.sliceCache.clear();
            state.currentSliceIndex = 0;

            // Reset view transforms and W/L for new series
            resetViewForNewSeries();

            document.querySelectorAll('.series-item').forEach(el => {
                el.classList.toggle('active', el.dataset.uid === seriesUid);
            });

            slider.max = Math.max(0, state.currentSeries.slices.length - 1);
            slider.value = 0;
            loadSlice(0);
        }

        function openViewer(studyUid, initialSeriesUid = null) {
            state.currentStudy = state.studies[studyUid];
            if (!state.currentStudy) return;

            studyTitle.textContent = `${state.currentStudy.patientName || 'Unknown'} - ${state.currentStudy.studyDescription || 'Study'}`;

            const seriesArr = Object.values(state.currentStudy.series);
            seriesList.innerHTML = seriesArr.map(s => `
                <div class="series-item" data-uid="${escapeHtml(s.seriesInstanceUid)}">
                    <div class="series-name">${escapeHtml(s.seriesDescription || 'Series ' + (s.seriesNumber || '?'))}</div>
                    <div class="series-info">${s.slices.length} slices</div>
                </div>
            `).join('');

            seriesList.querySelectorAll('.series-item').forEach(el => {
                el.onclick = () => selectSeries(el.dataset.uid);
            });

            libraryView.style.display = 'none';
            viewerView.style.display = 'flex';
            document.body.classList.add('viewer-page');

            // Select specified series or first one
            const seriesUidToSelect = initialSeriesUid && state.currentStudy.series[initialSeriesUid]
                ? initialSeriesUid
                : (seriesArr.length ? seriesArr[0].seriesInstanceUid : null);
            if (seriesUidToSelect) selectSeries(seriesUidToSelect);
        }

        function openViewerWithSeries(studyUid, seriesUid) {
            openViewer(studyUid, seriesUid);
        }

        function closeViewer() {
            viewerView.style.display = 'none';
            libraryView.style.display = 'block';
            document.body.classList.remove('viewer-page');
            state.currentStudy = null;
            state.currentSeries = null;
            state.sliceCache.clear();
        }

        // =====================================================================
        // VIEWING TOOLS
        // Window/Level, Pan, Zoom, Reset
        // =====================================================================

        /**
         * Set the active viewing tool
         * @param {string} tool - Tool name ('wl', 'pan', 'zoom', or null)
         */
        function setTool(tool) {
            state.currentTool = tool;
            // Update toolbar button states
            document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.tool === tool);
            });
            // Update cursor
            canvas.style.cursor = getCursorForTool(tool, false);
            // Update canvas container class for measure tool cursor
            canvasContainer.classList.toggle('tool-measure', tool === 'measure');
            // Update calibration warning visibility
            updateCalibrationWarning();
        }

        /**
         * Get appropriate cursor for the current tool
         * @param {string} tool - Tool name
         * @param {boolean} dragging - Whether currently dragging
         * @returns {string} CSS cursor value
         */
        function getCursorForTool(tool, dragging) {
            switch (tool) {
                case 'wl': return dragging ? 'ns-resize' : 'crosshair';
                case 'pan': return dragging ? 'grabbing' : 'grab';
                case 'zoom': return dragging ? 'ns-resize' : 'zoom-in';
                case 'measure': return 'crosshair';
                default: return 'default';
            }
        }

        /**
         * Apply CSS transform for pan and zoom
         */
        function applyViewTransform() {
            const { panX, panY, zoom } = state.viewTransform;
            canvas.style.transform = `translate(${panX}px, ${panY}px) scale(${zoom})`;
            canvas.style.transformOrigin = 'center center';
            // Redraw measurements to account for new transform
            drawMeasurements();
        }

        /**
         * Update the W/L display in the toolbar
         */
        function updateWLDisplay() {
            const wc = state.windowLevel.center ?? state.baseWindowLevel.center;
            const ww = state.windowLevel.width ?? state.baseWindowLevel.width;
            if (wc !== null && ww !== null) {
                wlDisplay.textContent = `C: ${Math.round(wc)} W: ${Math.round(ww)}`;
            }
        }

        /**
         * Re-render the current slice with current W/L settings
         */
        async function reRenderCurrentSlice() {
            if (!state.currentSeries) return;
            const dataSet = state.sliceCache.get(state.currentSliceIndex);
            if (dataSet) {
                const wlOverride = (state.windowLevel.center !== null && state.windowLevel.width !== null)
                    ? state.windowLevel : null;
                await renderDicom(dataSet, wlOverride);
            }
        }

        /**
         * Handle Window/Level drag
         */
        function handleWLDrag(dx, dy) {
            const sensitivity = 2;
            const currentWidth = state.windowLevel.width ?? state.baseWindowLevel.width;
            const currentCenter = state.windowLevel.center ?? state.baseWindowLevel.center;

            state.windowLevel.width = Math.max(1, currentWidth + dx * sensitivity);
            state.windowLevel.center = currentCenter - dy * sensitivity;

            reRenderCurrentSlice();
            updateWLDisplay();
        }

        /**
         * Handle Pan drag
         */
        function handlePanDrag(dx, dy) {
            state.viewTransform.panX += dx;
            state.viewTransform.panY += dy;
            applyViewTransform();
        }

        /**
         * Handle Zoom drag
         */
        function handleZoomDrag(dx, dy) {
            const sensitivity = 0.005;
            const delta = -dy * sensitivity;
            state.viewTransform.zoom = Math.max(0.1, Math.min(10, state.viewTransform.zoom + delta));
            applyViewTransform();
        }

        /**
         * Reset view to default state
         */
        function resetView() {
            state.viewTransform = { panX: 0, panY: 0, zoom: 1 };
            state.windowLevel = { center: null, width: null };
            applyViewTransform();
            reRenderCurrentSlice();
            updateWLDisplay();
        }

        /**
         * Reset view when switching series
         */
        function resetViewForNewSeries() {
            state.viewTransform = { panX: 0, panY: 0, zoom: 1 };
            state.windowLevel = { center: null, width: null };
            state.baseWindowLevel = { center: null, width: null };
            // Clear measurements for new series
            state.measurements.clear();
            state.activeMeasurement = null;
            state.pixelSpacing = null;
            applyViewTransform();
            updateCalibrationWarning();
        }

        // Mouse event handlers for canvas tools
        function onCanvasMouseDown(e) {
            if (!state.currentTool || e.button !== 0) return;

            // Handle measure tool separately
            if (state.currentTool === 'measure') {
                handleMeasureMouseDown(e);
                return;
            }

            state.isDragging = true;
            state.dragStart = { x: e.clientX, y: e.clientY };
            canvas.style.cursor = getCursorForTool(state.currentTool, true);
            e.preventDefault();
        }

        function onCanvasMouseMove(e) {
            // Handle measure tool separately
            if (state.currentTool === 'measure' && state.activeMeasurement) {
                handleMeasureMouseMove(e);
                return;
            }

            if (!state.isDragging) return;
            const dx = e.clientX - state.dragStart.x;
            const dy = e.clientY - state.dragStart.y;

            switch (state.currentTool) {
                case 'wl': handleWLDrag(dx, dy); break;
                case 'pan': handlePanDrag(dx, dy); break;
                case 'zoom': handleZoomDrag(dx, dy); break;
            }

            state.dragStart = { x: e.clientX, y: e.clientY };
        }

        function onCanvasMouseUp(e) {
            // Handle measure tool separately
            if (state.currentTool === 'measure' && state.activeMeasurement) {
                handleMeasureMouseUp(e);
                return;
            }

            if (state.isDragging) {
                state.isDragging = false;
                canvas.style.cursor = getCursorForTool(state.currentTool, false);
            }
        }

        /**
         * Handle mouse down for measure tool - start new measurement
         */
        function handleMeasureMouseDown(e) {
            const imageCoords = screenToImage(e.clientX, e.clientY);

            // Clamp to image bounds
            imageCoords.x = Math.max(0, Math.min(canvas.width - 1, imageCoords.x));
            imageCoords.y = Math.max(0, Math.min(canvas.height - 1, imageCoords.y));

            // Start new measurement
            state.activeMeasurement = createMeasurement(imageCoords, imageCoords);
            canvasContainer.classList.add('measuring');
            e.preventDefault();
        }

        /**
         * Handle mouse move for measure tool - update active measurement endpoint
         */
        function handleMeasureMouseMove(e) {
            if (!state.activeMeasurement) return;

            const imageCoords = screenToImage(e.clientX, e.clientY);

            // Clamp to image bounds
            imageCoords.x = Math.max(0, Math.min(canvas.width - 1, imageCoords.x));
            imageCoords.y = Math.max(0, Math.min(canvas.height - 1, imageCoords.y));

            // Update endpoint
            state.activeMeasurement.points[1] = { x: imageCoords.x, y: imageCoords.y };

            // Recalculate distance
            const { distancePixels, distanceMm } = calculateDistance(
                state.activeMeasurement.points[0],
                state.activeMeasurement.points[1],
                state.pixelSpacing
            );
            state.activeMeasurement.distancePixels = distancePixels;
            state.activeMeasurement.distanceMm = distanceMm;

            // Redraw
            drawMeasurements();
        }

        /**
         * Handle mouse up for measure tool - finalize measurement
         */
        function handleMeasureMouseUp(e) {
            if (!state.activeMeasurement) return;

            // Discard very small measurements (< 3 pixels)
            if (state.activeMeasurement.distancePixels < 3) {
                state.activeMeasurement = null;
                canvasContainer.classList.remove('measuring');
                drawMeasurements();
                return;
            }

            // Add to measurements collection
            addMeasurement(state.activeMeasurement);
            state.activeMeasurement = null;
            canvasContainer.classList.remove('measuring');
            drawMeasurements();
        }

        // =====================================================================
        // EVENT HANDLERS
        // Drag-and-drop, keyboard navigation, mouse wheel scrolling
        // =====================================================================

        // Drag-and-drop handlers for folder loading
        folderZone.addEventListener('dragover', e => { e.preventDefault(); folderZone.classList.add('dragover'); });
        folderZone.addEventListener('dragleave', e => { e.preventDefault(); folderZone.classList.remove('dragover'); });

        folderZone.addEventListener('drop', async e => {
            e.preventDefault();
            folderZone.classList.remove('dragover');

            uploadProgress.style.display = 'flex';
            progressText.textContent = 'Reading folder...';
            progressDetail.textContent = '';
            progressFill.style.width = '0%';

            try {
                const items = e.dataTransfer.items;
                if (!items?.[0]?.getAsFileSystemHandle) {
                    throw new Error('Please use Chrome or Edge for folder drop support');
                }

                const handle = await items[0].getAsFileSystemHandle();
                if (handle.kind !== 'directory') {
                    throw new Error('Please drop a folder, not a file');
                }

                progressText.textContent = 'Finding files...';
                const fileHandles = await getAllFileHandles(handle);
                progressDetail.textContent = `Found ${fileHandles.length} files`;

                if (!fileHandles.length) throw new Error('No files found');

                state.studies = await processFiles(fileHandles);
                uploadProgress.style.display = 'none';
                await displayStudies();

            } catch (err) {
                uploadProgress.style.display = 'none';
                alert('Error: ' + err.message);
            }
        });

        backBtn.onclick = e => { e.preventDefault(); closeViewer(); };
        slider.oninput = () => loadSlice(parseInt(slider.value));
        prevBtn.onclick = () => { if (state.currentSliceIndex > 0) loadSlice(state.currentSliceIndex - 1); };
        nextBtn.onclick = () => {
            if (state.currentSeries && state.currentSliceIndex < state.currentSeries.slices.length - 1)
                loadSlice(state.currentSliceIndex + 1);
        };

        // Load sample scan (reusable for CT and MRI)
        async function loadSampleScan(samplePath, button, buttonLabel) {
            button.disabled = true;
            button.textContent = 'Loading...';
            uploadProgress.style.display = 'flex';
            progressText.textContent = 'Loading sample scan...';
            progressDetail.textContent = '';
            progressFill.style.width = '0%';

            try {
                // Fetch the manifest of sample files
                const manifestRes = await fetch(`${samplePath}/manifest.json`);
                const fileNames = await manifestRes.json();

                progressText.textContent = 'Downloading DICOM files...';
                progressDetail.textContent = `0/${fileNames.length} files`;

                // Fetch all DICOM files
                const filePromises = fileNames.map(async (name, i) => {
                    const res = await fetch(`${samplePath}/${name}`);
                    const blob = await res.blob();
                    // Update progress periodically
                    if ((i + 1) % 5 === 0 || i === fileNames.length - 1) {
                        const pct = Math.round(((i + 1) / fileNames.length) * 50);
                        progressFill.style.width = pct + '%';
                        progressDetail.textContent = `${i + 1}/${fileNames.length} files`;
                    }
                    return { name, blob };
                });

                const files = await Promise.all(filePromises);

                progressText.textContent = 'Processing DICOM files...';
                progressFill.style.width = '50%';

                // Process files similar to processFiles but with blobs
                const studies = {};
                let processed = 0;

                for (const { name, blob } of files) {
                    const meta = await parseDicomMetadata(blob);
                    processed++;

                    const pct = 50 + Math.round((processed / files.length) * 50);
                    progressFill.style.width = pct + '%';
                    progressDetail.textContent = `Processing ${processed}/${files.length}`;

                    if (!meta?.studyInstanceUid) continue;

                    const studyUid = meta.studyInstanceUid;
                    const seriesUid = meta.seriesInstanceUid;

                    if (!studies[studyUid]) {
                        studies[studyUid] = {
                            ...meta,
                            series: {},
                            comments: []
                        };
                    }

                    if (!studies[studyUid].series[seriesUid]) {
                        studies[studyUid].series[seriesUid] = {
                            seriesInstanceUid: seriesUid,
                            seriesNumber: meta.seriesNumber,
                            seriesDescription: meta.seriesDescription,
                            modality: meta.modality,
                            transferSyntax: meta.transferSyntax,
                            slices: [],
                            comments: []
                        };
                    }

                    studies[studyUid].series[seriesUid].slices.push({
                        instanceNumber: meta.instanceNumber,
                        sliceLocation: meta.sliceLocation,
                        blob: blob  // Store blob instead of handle
                    });
                }

                // Sort slices and calculate counts
                for (const study of Object.values(studies)) {
                    let imageCount = 0;
                    for (const series of Object.values(study.series)) {
                        series.slices.sort((a, b) =>
                            (a.sliceLocation ?? a.instanceNumber ?? 0) -
                            (b.sliceLocation ?? b.instanceNumber ?? 0)
                        );
                        imageCount += series.slices.length;
                    }
                    study.seriesCount = Object.keys(study.series).length;
                    study.imageCount = imageCount;
                }

                state.studies = studies;
                uploadProgress.style.display = 'none';
                await displayStudies();
                button.textContent = buttonLabel;
                button.disabled = false;

            } catch (err) {
                uploadProgress.style.display = 'none';
                button.textContent = buttonLabel;
                button.disabled = false;
                alert('Error loading sample: ' + err.message);
            }
        }

        loadSampleCtBtn.onclick = () => loadSampleScan('sample', loadSampleCtBtn, 'CT Scan');
        loadSampleMriBtn.onclick = () => loadSampleScan('sample-mri', loadSampleMriBtn, 'MRI Scan');

        document.addEventListener('keydown', e => {
            const activeElement = document.activeElement;
            const activeTag = activeElement ? activeElement.tagName : '';
            const isTyping = activeTag === 'INPUT' || activeTag === 'TEXTAREA' || activeTag === 'SELECT' || !!activeElement?.isContentEditable;

            if (!isTyping && e.key.toLowerCase() === 'h') {
                e.preventDefault();
                openHelpViewer();
                return;
            }

            if (e.key === 'Escape' && $('helpViewer').style.display !== 'none') {
                closeHelpViewer();
                return;
            }

            if (viewerView.style.display === 'none') return;

            // Delete/Backspace for measurements when measure tool is active
            if ((e.key === 'Delete' || e.key === 'Backspace') && !isTyping && state.currentTool === 'measure') {
                e.preventDefault();
                if (e.shiftKey) {
                    clearSliceMeasurements();  // Shift+Delete clears all on slice
                } else {
                    deleteLastMeasurement();   // Delete removes most recent
                }
                return;
            }

            // Tool shortcuts (only when not typing in an input)
            if (!isTyping) {
                switch (e.key.toLowerCase()) {
                    case 'w': setTool('wl'); return;
                    case 'p': setTool('pan'); return;
                    case 'z': setTool('zoom'); return;
                    case 'm': setTool('measure'); return;
                    case 'r': resetView(); return;
                }
            }

            // Navigation shortcuts
            if (e.key === 'ArrowLeft' || e.key === 'ArrowUp') {
                e.preventDefault();
                if (state.currentSliceIndex > 0) loadSlice(state.currentSliceIndex - 1);
            } else if (e.key === 'ArrowRight' || e.key === 'ArrowDown') {
                e.preventDefault();
                if (state.currentSeries && state.currentSliceIndex < state.currentSeries.slices.length - 1)
                    loadSlice(state.currentSliceIndex + 1);
            } else if (e.key === 'Escape') {
                // Close report viewer first if open, otherwise close main viewer
                if ($('reportViewer').style.display !== 'none') {
                    closeReportViewer();
                } else {
                    closeViewer();
                }
            }
        });

        // Canvas mouse events for tools
        canvas.addEventListener('mousedown', onCanvasMouseDown);
        canvas.addEventListener('mousemove', onCanvasMouseMove);
        canvas.addEventListener('mouseup', onCanvasMouseUp);
        canvas.addEventListener('mouseleave', onCanvasMouseUp);

        // Right-click to delete measurement
        canvas.addEventListener('contextmenu', e => {
            if (state.currentTool !== 'measure') return;

            e.preventDefault();
            const imageCoords = screenToImage(e.clientX, e.clientY);
            const measurement = findMeasurementAtPoint(imageCoords.x, imageCoords.y);

            if (measurement) {
                deleteMeasurement(measurement.id);
            }
        });

        canvas.addEventListener('wheel', e => {
            e.preventDefault();
            if (state.currentTool === 'zoom') {
                // Zoom mode: scroll to zoom
                const delta = e.deltaY > 0 ? -0.1 : 0.1;
                state.viewTransform.zoom = Math.max(0.1, Math.min(10, state.viewTransform.zoom + delta));
                applyViewTransform();
            } else {
                // Default: scroll to navigate slices
                if (e.deltaY > 0) {
                    if (state.currentSeries && state.currentSliceIndex < state.currentSeries.slices.length - 1)
                        loadSlice(state.currentSliceIndex + 1);
                } else {
                    if (state.currentSliceIndex > 0) loadSlice(state.currentSliceIndex - 1);
                }
            }
        });

        // Toolbar button events
        document.querySelectorAll('.tool-btn[data-tool]').forEach(btn => {
            btn.addEventListener('click', () => setTool(btn.dataset.tool));
        });
        resetViewBtn.addEventListener('click', resetView);

        // Report viewer close button
        $('closeReportViewer').addEventListener('click', closeReportViewer);
        $('closeHelpViewer').addEventListener('click', closeHelpViewer);

        // Help buttons (library + viewer headers)
        document.querySelectorAll('.help-btn').forEach(btn => {
            btn.addEventListener('click', openHelpViewer);
        });

        // Initialize cursor for default tool
        canvas.style.cursor = getCursorForTool(state.currentTool, false);

        // =====================================================================
        // TEST MODE
        // When ?test is in the URL, load test data from the server API
        // instead of requiring File System Access API folder drop.
        // This enables automated testing with Playwright/Puppeteer.
        // =====================================================================

        /** Test mode flag - set when ?test URL parameter is present */
        const isTestMode = new URLSearchParams(window.location.search).has('test');

        /**
         * Load test data from the server API
         * @returns {Promise<Object>} Studies object matching the normal state.studies format
         */
        async function loadTestData() {
            const response = await fetch('/api/test-data/studies');
            if (!response.ok) throw new Error('Failed to load test data');

            const studiesArray = await response.json();
            const studies = {};

            for (const study of studiesArray) {
                const seriesMap = {};
                for (const series of study.series) {
                    seriesMap[series.seriesInstanceUid] = {
                        seriesInstanceUid: series.seriesInstanceUid,
                        seriesDescription: series.seriesDescription,
                        seriesNumber: series.seriesNumber,
                        modality: series.modality,
                        // Create slice objects that use API URLs instead of fileHandles
                        slices: Array.from({ length: series.sliceCount }, (_, i) => ({
                            instanceNumber: i + 1,
                            sliceLocation: 0,
                            // Store API info for test mode loading
                            testMode: true,
                            studyId: study.studyInstanceUid,
                            seriesId: series.seriesInstanceUid,
                            sliceIndex: i
                        }))
                    };
                }

                studies[study.studyInstanceUid] = {
                    patientName: study.patientName,
                    studyDate: study.studyDate,
                    studyDescription: study.studyDescription,
                    studyInstanceUid: study.studyInstanceUid,
                    modality: study.modality,
                    seriesCount: study.seriesCount,
                    imageCount: study.imageCount,
                    series: seriesMap
                };
            }

            return studies;
        }

        /**
         * Load a slice in test mode (fetches from API instead of fileHandle)
         * This is called from loadSlice when the slice has testMode: true
         */
        async function loadTestSlice(slice) {
            const url = `/api/test-data/dicom/${slice.studyId}/${slice.seriesId}/${slice.sliceIndex}`;
            const response = await fetch(url);
            if (!response.ok) throw new Error(`Failed to load test slice: ${response.status}`);

            const arrayBuffer = await response.arrayBuffer();
            return dicomParser.parseDicom(new Uint8Array(arrayBuffer));
        }

        // Patch loadSlice to handle test mode
        const originalLoadSlice = loadSlice;
        loadSlice = async function(index) {
            if (!state.currentSeries) return;
            const slices = state.currentSeries.slices;
            if (index < 0 || index >= slices.length) return;

            const slice = slices[index];

            // If this is a test mode slice, fetch from API
            if (slice.testMode) {
                state.currentSliceIndex = index;
                updateSliceInfo();
                imageLoading.style.display = 'block';

                try {
                    let dataSet = state.sliceCache.get(index);

                    if (!dataSet) {
                        dataSet = await loadTestSlice(slice);
                        state.sliceCache.set(index, dataSet);
                    }

                    // Pass W/L override if user has adjusted values
                    const wlOverride = (state.windowLevel.center !== null && state.windowLevel.width !== null)
                        ? state.windowLevel : null;
                    const info = await renderDicom(dataSet, wlOverride);

                    // Update W/L display in toolbar
                    updateWLDisplay();

                    if (info && !info.error && !info.isBlank) {
                        let metadataHtml = `
                            <div class="metadata-item"><div class="label">Slice</div><div class="value">${index + 1} / ${slices.length}</div></div>
                            <div class="metadata-item"><div class="label">Modality</div><div class="value">${escapeHtml(info.modality || '-')}</div></div>
                            <div class="metadata-item"><div class="label">Size</div><div class="value">${info.cols} x ${info.rows}</div></div>
                            <div class="metadata-item"><div class="label">Window</div><div class="value">C:${info.wc} W:${info.ww}</div></div>
                        `;
                        metadataContent.innerHTML = metadataHtml;
                    }

                    // Preload adjacent slices
                    for (let i = index - 2; i <= index + 2; i++) {
                        if (i >= 0 && i < slices.length && !state.sliceCache.has(i)) {
                            loadTestSlice(slices[i]).then(ds => {
                                state.sliceCache.set(i, ds);
                            }).catch(() => {});
                        }
                    }
                } catch (e) {
                    console.error('Error loading test slice:', e);
                }

                imageLoading.style.display = 'none';
                return;
            }

            // Normal mode - use original function
            return originalLoadSlice.call(this, index);
        };

        // Auto-load test data if in test mode
        if (isTestMode) {
            console.log('Test mode enabled - loading test data from server');
            (async () => {
                try {
                    uploadProgress.style.display = 'flex';
                    progressText.textContent = 'Loading test data...';
                    progressDetail.textContent = '';

                    state.studies = await loadTestData();

                    uploadProgress.style.display = 'none';
                    await displayStudies();

                    // Auto-open first study/series if available
                    const studyIds = Object.keys(state.studies);
                    if (studyIds.length > 0) {
                        const firstStudy = state.studies[studyIds[0]];
                        const seriesIds = Object.keys(firstStudy.series);
                        if (seriesIds.length > 0) {
                            console.log('Auto-opening first series for testing');
                            openViewerWithSeries(studyIds[0], seriesIds[0]);

                            // Auto-advance past blank slices to find displayable content
                            // MPR reconstructions often have blank padding slices at the start
                            const maxSkip = 50;
                            for (let i = 0; i < maxSkip && state.currentSeries; i++) {
                                // Check if current W/L is set (non-blank slice)
                                if (state.baseWindowLevel.center !== null) {
                                    console.log(`Found non-blank slice at index ${state.currentSliceIndex}`);
                                    break;
                                }
                                // Advance to next slice
                                if (state.currentSliceIndex < state.currentSeries.slices.length - 1) {
                                    await loadSlice(state.currentSliceIndex + 1);
                                } else {
                                    break;
                                }
                            }
                        }
                    }
                } catch (e) {
                    console.error('Failed to load test data:', e);
                    uploadProgress.style.display = 'none';
                    alert('Failed to load test data: ' + e.message);
                }
            })();
        } else {
            displayStudies();
        }
    </script>
</body>
</html>
